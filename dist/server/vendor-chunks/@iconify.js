"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@iconify";
exports.ids = ["vendor-chunks/@iconify"];
exports.modules = {

/***/ "(ssr)/./node_modules/@iconify/react/dist/iconify.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@iconify/react/dist/iconify.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Icon: () => (/* binding */ Icon),\n/* harmony export */   InlineIcon: () => (/* binding */ InlineIcon),\n/* harmony export */   _api: () => (/* binding */ _api),\n/* harmony export */   addAPIProvider: () => (/* binding */ addAPIProvider),\n/* harmony export */   addCollection: () => (/* binding */ addCollection),\n/* harmony export */   addIcon: () => (/* binding */ addIcon),\n/* harmony export */   buildIcon: () => (/* binding */ iconToSVG),\n/* harmony export */   calculateSize: () => (/* binding */ calculateSize),\n/* harmony export */   disableCache: () => (/* binding */ disableCache),\n/* harmony export */   enableCache: () => (/* binding */ enableCache),\n/* harmony export */   getIcon: () => (/* binding */ getIcon),\n/* harmony export */   iconExists: () => (/* binding */ iconExists),\n/* harmony export */   listIcons: () => (/* binding */ listIcons),\n/* harmony export */   loadIcon: () => (/* binding */ loadIcon),\n/* harmony export */   loadIcons: () => (/* binding */ loadIcons),\n/* harmony export */   replaceIDs: () => (/* binding */ replaceIDs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nconst stringToIcon = (value, validate, allowSimpleName, provider = \"\")=>{\n    const colonSeparated = value.split(\":\");\n    if (value.slice(0, 1) === \"@\") {\n        if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n            return null;\n        }\n        provider = colonSeparated.shift().slice(1);\n    }\n    if (colonSeparated.length > 3 || !colonSeparated.length) {\n        return null;\n    }\n    if (colonSeparated.length > 1) {\n        const name2 = colonSeparated.pop();\n        const prefix = colonSeparated.pop();\n        const result = {\n            // Allow provider without '@': \"provider:prefix:name\"\n            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n            prefix,\n            name: name2\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    const name = colonSeparated[0];\n    const dashSeparated = name.split(\"-\");\n    if (dashSeparated.length > 1) {\n        const result = {\n            provider,\n            prefix: dashSeparated.shift(),\n            name: dashSeparated.join(\"-\")\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    if (allowSimpleName && provider === \"\") {\n        const result = {\n            provider,\n            prefix: \"\",\n            name\n        };\n        return validate && !validateIconName(result, allowSimpleName) ? null : result;\n    }\n    return null;\n};\nconst validateIconName = (icon, allowSimpleName)=>{\n    if (!icon) {\n        return false;\n    }\n    return !!((icon.provider === \"\" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === \"\" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));\n};\nconst defaultIconDimensions = Object.freeze({\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n});\nconst defaultIconTransformations = Object.freeze({\n    rotate: 0,\n    vFlip: false,\n    hFlip: false\n});\nconst defaultIconProps = Object.freeze({\n    ...defaultIconDimensions,\n    ...defaultIconTransformations\n});\nconst defaultExtendedIconProps = Object.freeze({\n    ...defaultIconProps,\n    body: \"\",\n    hidden: false\n});\nfunction mergeIconTransformations(obj1, obj2) {\n    const result = {};\n    if (!obj1.hFlip !== !obj2.hFlip) {\n        result.hFlip = true;\n    }\n    if (!obj1.vFlip !== !obj2.vFlip) {\n        result.vFlip = true;\n    }\n    const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n    if (rotate) {\n        result.rotate = rotate;\n    }\n    return result;\n}\nfunction mergeIconData(parent, child) {\n    const result = mergeIconTransformations(parent, child);\n    for(const key in defaultExtendedIconProps){\n        if (key in defaultIconTransformations) {\n            if (key in parent && !(key in result)) {\n                result[key] = defaultIconTransformations[key];\n            }\n        } else if (key in child) {\n            result[key] = child[key];\n        } else if (key in parent) {\n            result[key] = parent[key];\n        }\n    }\n    return result;\n}\nfunction getIconsTree(data, names) {\n    const icons = data.icons;\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    const resolved = /* @__PURE__ */ Object.create(null);\n    function resolve(name) {\n        if (icons[name]) {\n            return resolved[name] = [];\n        }\n        if (!(name in resolved)) {\n            resolved[name] = null;\n            const parent = aliases[name] && aliases[name].parent;\n            const value = parent && resolve(parent);\n            if (value) {\n                resolved[name] = [\n                    parent\n                ].concat(value);\n            }\n        }\n        return resolved[name];\n    }\n    (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);\n    return resolved;\n}\nfunction internalGetIconData(data, name, tree) {\n    const icons = data.icons;\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    let currentProps = {};\n    function parse(name2) {\n        currentProps = mergeIconData(icons[name2] || aliases[name2], currentProps);\n    }\n    parse(name);\n    tree.forEach(parse);\n    return mergeIconData(data, currentProps);\n}\nfunction parseIconSet(data, callback) {\n    const names = [];\n    if (typeof data !== \"object\" || typeof data.icons !== \"object\") {\n        return names;\n    }\n    if (data.not_found instanceof Array) {\n        data.not_found.forEach((name)=>{\n            callback(name, null);\n            names.push(name);\n        });\n    }\n    const tree = getIconsTree(data);\n    for(const name in tree){\n        const item = tree[name];\n        if (item) {\n            callback(name, internalGetIconData(data, name, item));\n            names.push(name);\n        }\n    }\n    return names;\n}\nconst optionalPropertyDefaults = {\n    provider: \"\",\n    aliases: {},\n    not_found: {},\n    ...defaultIconDimensions\n};\nfunction checkOptionalProps(item, defaults) {\n    for(const prop in defaults){\n        if (prop in item && typeof item[prop] !== typeof defaults[prop]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction quicklyValidateIconSet(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return null;\n    }\n    const data = obj;\n    if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") {\n        return null;\n    }\n    if (!checkOptionalProps(obj, optionalPropertyDefaults)) {\n        return null;\n    }\n    const icons = data.icons;\n    for(const name in icons){\n        const icon = icons[name];\n        if (!name.match(matchIconName) || typeof icon.body !== \"string\" || !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    for(const name in aliases){\n        const icon = aliases[name];\n        const parent = icon.parent;\n        if (!name.match(matchIconName) || typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    return data;\n}\nconst dataStorage = /* @__PURE__ */ Object.create(null);\nfunction newStorage(provider, prefix) {\n    return {\n        provider,\n        prefix,\n        icons: /* @__PURE__ */ Object.create(null),\n        missing: /* @__PURE__ */ new Set()\n    };\n}\nfunction getStorage(provider, prefix) {\n    const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));\n    return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\nfunction addIconSet(storage, data) {\n    if (!quicklyValidateIconSet(data)) {\n        return [];\n    }\n    return parseIconSet(data, (name, icon)=>{\n        if (icon) {\n            storage.icons[name] = icon;\n        } else {\n            storage.missing.add(name);\n        }\n    });\n}\nfunction addIconToStorage(storage, name, icon) {\n    try {\n        if (typeof icon.body === \"string\") {\n            storage.icons[name] = {\n                ...icon\n            };\n            return true;\n        }\n    } catch (err) {}\n    return false;\n}\nfunction listIcons(provider, prefix) {\n    let allIcons = [];\n    const providers = typeof provider === \"string\" ? [\n        provider\n    ] : Object.keys(dataStorage);\n    providers.forEach((provider2)=>{\n        const prefixes = typeof provider2 === \"string\" && typeof prefix === \"string\" ? [\n            prefix\n        ] : Object.keys(dataStorage[provider2] || {});\n        prefixes.forEach((prefix2)=>{\n            const storage = getStorage(provider2, prefix2);\n            allIcons = allIcons.concat(Object.keys(storage.icons).map((name)=>(provider2 !== \"\" ? \"@\" + provider2 + \":\" : \"\") + prefix2 + \":\" + name));\n        });\n    });\n    return allIcons;\n}\nlet simpleNames = false;\nfunction allowSimpleNames(allow) {\n    if (typeof allow === \"boolean\") {\n        simpleNames = allow;\n    }\n    return simpleNames;\n}\nfunction getIconData(name) {\n    const icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n    if (icon) {\n        const storage = getStorage(icon.provider, icon.prefix);\n        const iconName = icon.name;\n        return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n    }\n}\nfunction addIcon(name, data) {\n    const icon = stringToIcon(name, true, simpleNames);\n    if (!icon) {\n        return false;\n    }\n    const storage = getStorage(icon.provider, icon.prefix);\n    return addIconToStorage(storage, icon.name, data);\n}\nfunction addCollection(data, provider) {\n    if (typeof data !== \"object\") {\n        return false;\n    }\n    if (typeof provider !== \"string\") {\n        provider = data.provider || \"\";\n    }\n    if (simpleNames && !provider && !data.prefix) {\n        let added = false;\n        if (quicklyValidateIconSet(data)) {\n            data.prefix = \"\";\n            parseIconSet(data, (name, icon)=>{\n                if (icon && addIcon(name, icon)) {\n                    added = true;\n                }\n            });\n        }\n        return added;\n    }\n    const prefix = data.prefix;\n    if (!validateIconName({\n        provider,\n        prefix,\n        name: \"a\"\n    })) {\n        return false;\n    }\n    const storage = getStorage(provider, prefix);\n    return !!addIconSet(storage, data);\n}\nfunction iconExists(name) {\n    return !!getIconData(name);\n}\nfunction getIcon(name) {\n    const result = getIconData(name);\n    return result ? {\n        ...defaultIconProps,\n        ...result\n    } : null;\n}\nconst defaultIconSizeCustomisations = Object.freeze({\n    width: null,\n    height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n    // Dimensions\n    ...defaultIconSizeCustomisations,\n    // Transformations\n    ...defaultIconTransformations\n});\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n    if (ratio === 1) {\n        return size;\n    }\n    precision = precision || 100;\n    if (typeof size === \"number\") {\n        return Math.ceil(size * ratio * precision) / precision;\n    }\n    if (typeof size !== \"string\") {\n        return size;\n    }\n    const oldParts = size.split(unitsSplit);\n    if (oldParts === null || !oldParts.length) {\n        return size;\n    }\n    const newParts = [];\n    let code = oldParts.shift();\n    let isNumber = unitsTest.test(code);\n    while(true){\n        if (isNumber) {\n            const num = parseFloat(code);\n            if (isNaN(num)) {\n                newParts.push(code);\n            } else {\n                newParts.push(Math.ceil(num * ratio * precision) / precision);\n            }\n        } else {\n            newParts.push(code);\n        }\n        code = oldParts.shift();\n        if (code === void 0) {\n            return newParts.join(\"\");\n        }\n        isNumber = !isNumber;\n    }\n}\nconst isUnsetKeyword = (value)=>value === \"unset\" || value === \"undefined\" || value === \"none\";\nfunction iconToSVG(icon, customisations) {\n    const fullIcon = {\n        ...defaultIconProps,\n        ...icon\n    };\n    const fullCustomisations = {\n        ...defaultIconCustomisations,\n        ...customisations\n    };\n    const box = {\n        left: fullIcon.left,\n        top: fullIcon.top,\n        width: fullIcon.width,\n        height: fullIcon.height\n    };\n    let body = fullIcon.body;\n    [\n        fullIcon,\n        fullCustomisations\n    ].forEach((props)=>{\n        const transformations = [];\n        const hFlip = props.hFlip;\n        const vFlip = props.vFlip;\n        let rotation = props.rotate;\n        if (hFlip) {\n            if (vFlip) {\n                rotation += 2;\n            } else {\n                transformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n                transformations.push(\"scale(-1 1)\");\n                box.top = box.left = 0;\n            }\n        } else if (vFlip) {\n            transformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n            transformations.push(\"scale(1 -1)\");\n            box.top = box.left = 0;\n        }\n        let tempValue;\n        if (rotation < 0) {\n            rotation -= Math.floor(rotation / 4) * 4;\n        }\n        rotation = rotation % 4;\n        switch(rotation){\n            case 1:\n                tempValue = box.height / 2 + box.top;\n                transformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n            case 2:\n                transformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n                break;\n            case 3:\n                tempValue = box.width / 2 + box.left;\n                transformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n        }\n        if (rotation % 2 === 1) {\n            if (box.left !== box.top) {\n                tempValue = box.left;\n                box.left = box.top;\n                box.top = tempValue;\n            }\n            if (box.width !== box.height) {\n                tempValue = box.width;\n                box.width = box.height;\n                box.height = tempValue;\n            }\n        }\n        if (transformations.length) {\n            body = '<g transform=\"' + transformations.join(\" \") + '\">' + body + \"</g>\";\n        }\n    });\n    const customisationsWidth = fullCustomisations.width;\n    const customisationsHeight = fullCustomisations.height;\n    const boxWidth = box.width;\n    const boxHeight = box.height;\n    let width;\n    let height;\n    if (customisationsWidth === null) {\n        height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n        width = calculateSize(height, boxWidth / boxHeight);\n    } else {\n        width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n        height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    }\n    const attributes = {};\n    const setAttr = (prop, value)=>{\n        if (!isUnsetKeyword(value)) {\n            attributes[prop] = value.toString();\n        }\n    };\n    setAttr(\"width\", width);\n    setAttr(\"height\", height);\n    attributes.viewBox = box.left.toString() + \" \" + box.top.toString() + \" \" + boxWidth.toString() + \" \" + boxHeight.toString();\n    return {\n        attributes,\n        body\n    };\n}\nconst regex = /\\sid=\"(\\S+)\"/g;\nconst randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\nlet counter = 0;\nfunction replaceIDs(body, prefix = randomPrefix) {\n    const ids = [];\n    let match;\n    while(match = regex.exec(body)){\n        ids.push(match[1]);\n    }\n    if (!ids.length) {\n        return body;\n    }\n    const suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n    ids.forEach((id)=>{\n        const newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n        const escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        body = body.replace(// Allowed characters before id: [#;\"]\n        // Allowed characters after id: [)\"], .[a-z]\n        new RegExp('([#;\"])(' + escapedID + ')([\")]|\\\\.[a-z])', \"g\"), \"$1\" + newID + suffix + \"$3\");\n    });\n    body = body.replace(new RegExp(suffix, \"g\"), \"\");\n    return body;\n}\nconst storage = /* @__PURE__ */ Object.create(null);\nfunction setAPIModule(provider, item) {\n    storage[provider] = item;\n}\nfunction getAPIModule(provider) {\n    return storage[provider] || storage[\"\"];\n}\nfunction createAPIConfig(source) {\n    let resources;\n    if (typeof source.resources === \"string\") {\n        resources = [\n            source.resources\n        ];\n    } else {\n        resources = source.resources;\n        if (!(resources instanceof Array) || !resources.length) {\n            return null;\n        }\n    }\n    const result = {\n        // API hosts\n        resources,\n        // Root path\n        path: source.path || \"/\",\n        // URL length limit\n        maxURL: source.maxURL || 500,\n        // Timeout before next host is used.\n        rotate: source.rotate || 750,\n        // Timeout before failing query.\n        timeout: source.timeout || 5e3,\n        // Randomise default API end point.\n        random: source.random === true,\n        // Start index\n        index: source.index || 0,\n        // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n        dataAfterTimeout: source.dataAfterTimeout !== false\n    };\n    return result;\n}\nconst configStorage = /* @__PURE__ */ Object.create(null);\nconst fallBackAPISources = [\n    \"https://api.simplesvg.com\",\n    \"https://api.unisvg.com\"\n];\nconst fallBackAPI = [];\nwhile(fallBackAPISources.length > 0){\n    if (fallBackAPISources.length === 1) {\n        fallBackAPI.push(fallBackAPISources.shift());\n    } else {\n        if (Math.random() > 0.5) {\n            fallBackAPI.push(fallBackAPISources.shift());\n        } else {\n            fallBackAPI.push(fallBackAPISources.pop());\n        }\n    }\n}\nconfigStorage[\"\"] = createAPIConfig({\n    resources: [\n        \"https://api.iconify.design\"\n    ].concat(fallBackAPI)\n});\nfunction addAPIProvider(provider, customConfig) {\n    const config = createAPIConfig(customConfig);\n    if (config === null) {\n        return false;\n    }\n    configStorage[provider] = config;\n    return true;\n}\nfunction getAPIConfig(provider) {\n    return configStorage[provider];\n}\nfunction listAPIProviders() {\n    return Object.keys(configStorage);\n}\nconst detectFetch = ()=>{\n    let callback;\n    try {\n        callback = fetch;\n        if (typeof callback === \"function\") {\n            return callback;\n        }\n    } catch (err) {}\n};\nlet fetchModule = detectFetch();\nfunction setFetch(fetch2) {\n    fetchModule = fetch2;\n}\nfunction getFetch() {\n    return fetchModule;\n}\nfunction calculateMaxLength(provider, prefix) {\n    const config = getAPIConfig(provider);\n    if (!config) {\n        return 0;\n    }\n    let result;\n    if (!config.maxURL) {\n        result = 0;\n    } else {\n        let maxHostLength = 0;\n        config.resources.forEach((item)=>{\n            const host = item;\n            maxHostLength = Math.max(maxHostLength, host.length);\n        });\n        const url = prefix + \".json?icons=\";\n        result = config.maxURL - maxHostLength - config.path.length - url.length;\n    }\n    return result;\n}\nfunction shouldAbort(status) {\n    return status === 404;\n}\nconst prepare = (provider, prefix, icons)=>{\n    const results = [];\n    const maxLength = calculateMaxLength(provider, prefix);\n    const type = \"icons\";\n    let item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n    };\n    let length = 0;\n    icons.forEach((name, index)=>{\n        length += name.length + 1;\n        if (length >= maxLength && index > 0) {\n            results.push(item);\n            item = {\n                type,\n                provider,\n                prefix,\n                icons: []\n            };\n            length = name.length;\n        }\n        item.icons.push(name);\n    });\n    results.push(item);\n    return results;\n};\nfunction getPath(provider) {\n    if (typeof provider === \"string\") {\n        const config = getAPIConfig(provider);\n        if (config) {\n            return config.path;\n        }\n    }\n    return \"/\";\n}\nconst send = (host, params, callback)=>{\n    if (!fetchModule) {\n        callback(\"abort\", 424);\n        return;\n    }\n    let path = getPath(params.provider);\n    switch(params.type){\n        case \"icons\":\n            {\n                const prefix = params.prefix;\n                const icons = params.icons;\n                const iconsList = icons.join(\",\");\n                const urlParams = new URLSearchParams({\n                    icons: iconsList\n                });\n                path += prefix + \".json?\" + urlParams.toString();\n                break;\n            }\n        case \"custom\":\n            {\n                const uri = params.uri;\n                path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n                break;\n            }\n        default:\n            callback(\"abort\", 400);\n            return;\n    }\n    let defaultError = 503;\n    fetchModule(host + path).then((response)=>{\n        const status = response.status;\n        if (status !== 200) {\n            setTimeout(()=>{\n                callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n            });\n            return;\n        }\n        defaultError = 501;\n        return response.json();\n    }).then((data)=>{\n        if (typeof data !== \"object\" || data === null) {\n            setTimeout(()=>{\n                if (data === 404) {\n                    callback(\"abort\", data);\n                } else {\n                    callback(\"next\", defaultError);\n                }\n            });\n            return;\n        }\n        setTimeout(()=>{\n            callback(\"success\", data);\n        });\n    }).catch(()=>{\n        callback(\"next\", defaultError);\n    });\n};\nconst fetchAPIModule = {\n    prepare,\n    send\n};\nfunction sortIcons(icons) {\n    const result = {\n        loaded: [],\n        missing: [],\n        pending: []\n    };\n    const storage = /* @__PURE__ */ Object.create(null);\n    icons.sort((a, b)=>{\n        if (a.provider !== b.provider) {\n            return a.provider.localeCompare(b.provider);\n        }\n        if (a.prefix !== b.prefix) {\n            return a.prefix.localeCompare(b.prefix);\n        }\n        return a.name.localeCompare(b.name);\n    });\n    let lastIcon = {\n        provider: \"\",\n        prefix: \"\",\n        name: \"\"\n    };\n    icons.forEach((icon)=>{\n        if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {\n            return;\n        }\n        lastIcon = icon;\n        const provider = icon.provider;\n        const prefix = icon.prefix;\n        const name = icon.name;\n        const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));\n        const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n        let list;\n        if (name in localStorage.icons) {\n            list = result.loaded;\n        } else if (prefix === \"\" || localStorage.missing.has(name)) {\n            list = result.missing;\n        } else {\n            list = result.pending;\n        }\n        const item = {\n            provider,\n            prefix,\n            name\n        };\n        list.push(item);\n    });\n    return result;\n}\nfunction removeCallback(storages, id) {\n    storages.forEach((storage)=>{\n        const items = storage.loaderCallbacks;\n        if (items) {\n            storage.loaderCallbacks = items.filter((row)=>row.id !== id);\n        }\n    });\n}\nfunction updateCallbacks(storage) {\n    if (!storage.pendingCallbacksFlag) {\n        storage.pendingCallbacksFlag = true;\n        setTimeout(()=>{\n            storage.pendingCallbacksFlag = false;\n            const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n            if (!items.length) {\n                return;\n            }\n            let hasPending = false;\n            const provider = storage.provider;\n            const prefix = storage.prefix;\n            items.forEach((item)=>{\n                const icons = item.icons;\n                const oldLength = icons.pending.length;\n                icons.pending = icons.pending.filter((icon)=>{\n                    if (icon.prefix !== prefix) {\n                        return true;\n                    }\n                    const name = icon.name;\n                    if (storage.icons[name]) {\n                        icons.loaded.push({\n                            provider,\n                            prefix,\n                            name\n                        });\n                    } else if (storage.missing.has(name)) {\n                        icons.missing.push({\n                            provider,\n                            prefix,\n                            name\n                        });\n                    } else {\n                        hasPending = true;\n                        return true;\n                    }\n                    return false;\n                });\n                if (icons.pending.length !== oldLength) {\n                    if (!hasPending) {\n                        removeCallback([\n                            storage\n                        ], item.id);\n                    }\n                    item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n                }\n            });\n        });\n    }\n}\nlet idCounter = 0;\nfunction storeCallback(callback, icons, pendingSources) {\n    const id = idCounter++;\n    const abort = removeCallback.bind(null, pendingSources, id);\n    if (!icons.pending.length) {\n        return abort;\n    }\n    const item = {\n        id,\n        icons,\n        callback,\n        abort\n    };\n    pendingSources.forEach((storage)=>{\n        (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n    });\n    return abort;\n}\nfunction listToIcons(list, validate = true, simpleNames = false) {\n    const result = [];\n    list.forEach((item)=>{\n        const icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n        if (icon) {\n            result.push(icon);\n        }\n    });\n    return result;\n}\n// src/config.ts\nvar defaultConfig = {\n    resources: [],\n    index: 0,\n    timeout: 2e3,\n    rotate: 750,\n    random: false,\n    dataAfterTimeout: false\n};\n// src/query.ts\nfunction sendQuery(config, payload, query, done) {\n    const resourcesCount = config.resources.length;\n    const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n    let resources;\n    if (config.random) {\n        let list = config.resources.slice(0);\n        resources = [];\n        while(list.length > 1){\n            const nextIndex = Math.floor(Math.random() * list.length);\n            resources.push(list[nextIndex]);\n            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n        }\n        resources = resources.concat(list);\n    } else {\n        resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n    }\n    const startTime = Date.now();\n    let status = \"pending\";\n    let queriesSent = 0;\n    let lastError;\n    let timer = null;\n    let queue = [];\n    let doneCallbacks = [];\n    if (typeof done === \"function\") {\n        doneCallbacks.push(done);\n    }\n    function resetTimer() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    }\n    function abort() {\n        if (status === \"pending\") {\n            status = \"aborted\";\n        }\n        resetTimer();\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function subscribe(callback, overwrite) {\n        if (overwrite) {\n            doneCallbacks = [];\n        }\n        if (typeof callback === \"function\") {\n            doneCallbacks.push(callback);\n        }\n    }\n    function getQueryStatus() {\n        return {\n            startTime,\n            payload,\n            status,\n            queriesSent,\n            queriesPending: queue.length,\n            subscribe,\n            abort\n        };\n    }\n    function failQuery() {\n        status = \"failed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(void 0, lastError);\n        });\n    }\n    function clearQueue() {\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function moduleResponse(item, response, data) {\n        const isError = response !== \"success\";\n        queue = queue.filter((queued)=>queued !== item);\n        switch(status){\n            case \"pending\":\n                break;\n            case \"failed\":\n                if (isError || !config.dataAfterTimeout) {\n                    return;\n                }\n                break;\n            default:\n                return;\n        }\n        if (response === \"abort\") {\n            lastError = data;\n            failQuery();\n            return;\n        }\n        if (isError) {\n            lastError = data;\n            if (!queue.length) {\n                if (!resources.length) {\n                    failQuery();\n                } else {\n                    execNext();\n                }\n            }\n            return;\n        }\n        resetTimer();\n        clearQueue();\n        if (!config.random) {\n            const index = config.resources.indexOf(item.resource);\n            if (index !== -1 && index !== config.index) {\n                config.index = index;\n            }\n        }\n        status = \"completed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(data);\n        });\n    }\n    function execNext() {\n        if (status !== \"pending\") {\n            return;\n        }\n        resetTimer();\n        const resource = resources.shift();\n        if (resource === void 0) {\n            if (queue.length) {\n                timer = setTimeout(()=>{\n                    resetTimer();\n                    if (status === \"pending\") {\n                        clearQueue();\n                        failQuery();\n                    }\n                }, config.timeout);\n                return;\n            }\n            failQuery();\n            return;\n        }\n        const item = {\n            status: \"pending\",\n            resource,\n            callback: (status2, data)=>{\n                moduleResponse(item, status2, data);\n            }\n        };\n        queue.push(item);\n        queriesSent++;\n        timer = setTimeout(execNext, config.rotate);\n        query(resource, payload, item.callback);\n    }\n    setTimeout(execNext);\n    return getQueryStatus;\n}\n// src/index.ts\nfunction initRedundancy(cfg) {\n    const config = {\n        ...defaultConfig,\n        ...cfg\n    };\n    let queries = [];\n    function cleanup() {\n        queries = queries.filter((item)=>item().status === \"pending\");\n    }\n    function query(payload, queryCallback, doneCallback) {\n        const query2 = sendQuery(config, payload, queryCallback, (data, error)=>{\n            cleanup();\n            if (doneCallback) {\n                doneCallback(data, error);\n            }\n        });\n        queries.push(query2);\n        return query2;\n    }\n    function find(callback) {\n        return queries.find((value)=>{\n            return callback(value);\n        }) || null;\n    }\n    const instance = {\n        query,\n        find,\n        setIndex: (index)=>{\n            config.index = index;\n        },\n        getIndex: ()=>config.index,\n        cleanup\n    };\n    return instance;\n}\nfunction emptyCallback$1() {}\nconst redundancyCache = /* @__PURE__ */ Object.create(null);\nfunction getRedundancyCache(provider) {\n    if (!redundancyCache[provider]) {\n        const config = getAPIConfig(provider);\n        if (!config) {\n            return;\n        }\n        const redundancy = initRedundancy(config);\n        const cachedReundancy = {\n            config,\n            redundancy\n        };\n        redundancyCache[provider] = cachedReundancy;\n    }\n    return redundancyCache[provider];\n}\nfunction sendAPIQuery(target, query, callback) {\n    let redundancy;\n    let send;\n    if (typeof target === \"string\") {\n        const api = getAPIModule(target);\n        if (!api) {\n            callback(void 0, 424);\n            return emptyCallback$1;\n        }\n        send = api.send;\n        const cached = getRedundancyCache(target);\n        if (cached) {\n            redundancy = cached.redundancy;\n        }\n    } else {\n        const config = createAPIConfig(target);\n        if (config) {\n            redundancy = initRedundancy(config);\n            const moduleKey = target.resources ? target.resources[0] : \"\";\n            const api = getAPIModule(moduleKey);\n            if (api) {\n                send = api.send;\n            }\n        }\n    }\n    if (!redundancy || !send) {\n        callback(void 0, 424);\n        return emptyCallback$1;\n    }\n    return redundancy.query(query, send, callback)().abort;\n}\nconst browserCacheVersion = \"iconify2\";\nconst browserCachePrefix = \"iconify\";\nconst browserCacheCountKey = browserCachePrefix + \"-count\";\nconst browserCacheVersionKey = browserCachePrefix + \"-version\";\nconst browserStorageHour = 36e5;\nconst browserStorageCacheExpiration = 168;\nfunction getStoredItem(func, key) {\n    try {\n        return func.getItem(key);\n    } catch (err) {}\n}\nfunction setStoredItem(func, key, value) {\n    try {\n        func.setItem(key, value);\n        return true;\n    } catch (err) {}\n}\nfunction removeStoredItem(func, key) {\n    try {\n        func.removeItem(key);\n    } catch (err) {}\n}\nfunction setBrowserStorageItemsCount(storage, value) {\n    return setStoredItem(storage, browserCacheCountKey, value.toString());\n}\nfunction getBrowserStorageItemsCount(storage) {\n    return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;\n}\nconst browserStorageConfig = {\n    local: true,\n    session: true\n};\nconst browserStorageEmptyItems = {\n    local: /* @__PURE__ */ new Set(),\n    session: /* @__PURE__ */ new Set()\n};\nlet browserStorageStatus = false;\nfunction setBrowserStorageStatus(status) {\n    browserStorageStatus = status;\n}\nlet _window =  true ? {} : 0;\nfunction getBrowserStorage(key) {\n    const attr = key + \"Storage\";\n    try {\n        if (_window && _window[attr] && typeof _window[attr].length === \"number\") {\n            return _window[attr];\n        }\n    } catch (err) {}\n    browserStorageConfig[key] = false;\n}\nfunction iterateBrowserStorage(key, callback) {\n    const func = getBrowserStorage(key);\n    if (!func) {\n        return;\n    }\n    const version = getStoredItem(func, browserCacheVersionKey);\n    if (version !== browserCacheVersion) {\n        if (version) {\n            const total2 = getBrowserStorageItemsCount(func);\n            for(let i = 0; i < total2; i++){\n                removeStoredItem(func, browserCachePrefix + i.toString());\n            }\n        }\n        setStoredItem(func, browserCacheVersionKey, browserCacheVersion);\n        setBrowserStorageItemsCount(func, 0);\n        return;\n    }\n    const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;\n    const parseItem = (index)=>{\n        const name = browserCachePrefix + index.toString();\n        const item = getStoredItem(func, name);\n        if (typeof item !== \"string\") {\n            return;\n        }\n        try {\n            const data = JSON.parse(item);\n            if (typeof data === \"object\" && typeof data.cached === \"number\" && data.cached > minTime && typeof data.provider === \"string\" && typeof data.data === \"object\" && typeof data.data.prefix === \"string\" && // Valid item: run callback\n            callback(data, index)) {\n                return true;\n            }\n        } catch (err) {}\n        removeStoredItem(func, name);\n    };\n    let total = getBrowserStorageItemsCount(func);\n    for(let i = total - 1; i >= 0; i--){\n        if (!parseItem(i)) {\n            if (i === total - 1) {\n                total--;\n                setBrowserStorageItemsCount(func, total);\n            } else {\n                browserStorageEmptyItems[key].add(i);\n            }\n        }\n    }\n}\nfunction initBrowserStorage() {\n    if (browserStorageStatus) {\n        return;\n    }\n    setBrowserStorageStatus(true);\n    for(const key in browserStorageConfig){\n        iterateBrowserStorage(key, (item)=>{\n            const iconSet = item.data;\n            const provider = item.provider;\n            const prefix = iconSet.prefix;\n            const storage = getStorage(provider, prefix);\n            if (!addIconSet(storage, iconSet).length) {\n                return false;\n            }\n            const lastModified = iconSet.lastModified || -1;\n            storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;\n            return true;\n        });\n    }\n}\nfunction updateLastModified(storage, lastModified) {\n    const lastValue = storage.lastModifiedCached;\n    if (// Matches or newer\n    lastValue && lastValue >= lastModified) {\n        return lastValue === lastModified;\n    }\n    storage.lastModifiedCached = lastModified;\n    if (lastValue) {\n        for(const key in browserStorageConfig){\n            iterateBrowserStorage(key, (item)=>{\n                const iconSet = item.data;\n                return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;\n            });\n        }\n    }\n    return true;\n}\nfunction storeInBrowserStorage(storage, data) {\n    if (!browserStorageStatus) {\n        initBrowserStorage();\n    }\n    function store(key) {\n        let func;\n        if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {\n            return;\n        }\n        const set = browserStorageEmptyItems[key];\n        let index;\n        if (set.size) {\n            set.delete(index = Array.from(set).shift());\n        } else {\n            index = getBrowserStorageItemsCount(func);\n            if (!setBrowserStorageItemsCount(func, index + 1)) {\n                return;\n            }\n        }\n        const item = {\n            cached: Math.floor(Date.now() / browserStorageHour),\n            provider: storage.provider,\n            data\n        };\n        return setStoredItem(func, browserCachePrefix + index.toString(), JSON.stringify(item));\n    }\n    if (data.lastModified && !updateLastModified(storage, data.lastModified)) {\n        return;\n    }\n    if (!Object.keys(data.icons).length) {\n        return;\n    }\n    if (data.not_found) {\n        data = Object.assign({}, data);\n        delete data.not_found;\n    }\n    if (!store(\"local\")) {\n        store(\"session\");\n    }\n}\nfunction emptyCallback() {}\nfunction loadedNewIcons(storage) {\n    if (!storage.iconsLoaderFlag) {\n        storage.iconsLoaderFlag = true;\n        setTimeout(()=>{\n            storage.iconsLoaderFlag = false;\n            updateCallbacks(storage);\n        });\n    }\n}\nfunction loadNewIcons(storage, icons) {\n    if (!storage.iconsToLoad) {\n        storage.iconsToLoad = icons;\n    } else {\n        storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n    }\n    if (!storage.iconsQueueFlag) {\n        storage.iconsQueueFlag = true;\n        setTimeout(()=>{\n            storage.iconsQueueFlag = false;\n            const { provider, prefix } = storage;\n            const icons2 = storage.iconsToLoad;\n            delete storage.iconsToLoad;\n            let api;\n            if (!icons2 || !(api = getAPIModule(provider))) {\n                return;\n            }\n            const params = api.prepare(provider, prefix, icons2);\n            params.forEach((item)=>{\n                sendAPIQuery(provider, item, (data)=>{\n                    if (typeof data !== \"object\") {\n                        item.icons.forEach((name)=>{\n                            storage.missing.add(name);\n                        });\n                    } else {\n                        try {\n                            const parsed = addIconSet(storage, data);\n                            if (!parsed.length) {\n                                return;\n                            }\n                            const pending = storage.pendingIcons;\n                            if (pending) {\n                                parsed.forEach((name)=>{\n                                    pending.delete(name);\n                                });\n                            }\n                            storeInBrowserStorage(storage, data);\n                        } catch (err) {\n                            console.error(err);\n                        }\n                    }\n                    loadedNewIcons(storage);\n                });\n            });\n        });\n    }\n}\nconst loadIcons = (icons, callback)=>{\n    const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n    const sortedIcons = sortIcons(cleanedIcons);\n    if (!sortedIcons.pending.length) {\n        let callCallback = true;\n        if (callback) {\n            setTimeout(()=>{\n                if (callCallback) {\n                    callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n                }\n            });\n        }\n        return ()=>{\n            callCallback = false;\n        };\n    }\n    const newIcons = /* @__PURE__ */ Object.create(null);\n    const sources = [];\n    let lastProvider, lastPrefix;\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix } = icon;\n        if (prefix === lastPrefix && provider === lastProvider) {\n            return;\n        }\n        lastProvider = provider;\n        lastPrefix = prefix;\n        sources.push(getStorage(provider, prefix));\n        const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));\n        if (!providerNewIcons[prefix]) {\n            providerNewIcons[prefix] = [];\n        }\n    });\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix, name } = icon;\n        const storage = getStorage(provider, prefix);\n        const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n        if (!pendingQueue.has(name)) {\n            pendingQueue.add(name);\n            newIcons[provider][prefix].push(name);\n        }\n    });\n    sources.forEach((storage)=>{\n        const { provider, prefix } = storage;\n        if (newIcons[provider][prefix].length) {\n            loadNewIcons(storage, newIcons[provider][prefix]);\n        }\n    });\n    return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\nconst loadIcon = (icon)=>{\n    return new Promise((fulfill, reject)=>{\n        const iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n        if (!iconObj) {\n            reject(icon);\n            return;\n        }\n        loadIcons([\n            iconObj || icon\n        ], (loaded)=>{\n            if (loaded.length && iconObj) {\n                const data = getIconData(iconObj);\n                if (data) {\n                    fulfill({\n                        ...defaultIconProps,\n                        ...data\n                    });\n                    return;\n                }\n            }\n            reject(icon);\n        });\n    });\n};\nfunction toggleBrowserCache(storage, value) {\n    switch(storage){\n        case \"local\":\n        case \"session\":\n            browserStorageConfig[storage] = value;\n            break;\n        case \"all\":\n            for(const key in browserStorageConfig){\n                browserStorageConfig[key] = value;\n            }\n            break;\n    }\n}\nfunction mergeCustomisations(defaults, item) {\n    const result = {\n        ...defaults\n    };\n    for(const key in item){\n        const value = item[key];\n        const valueType = typeof value;\n        if (key in defaultIconSizeCustomisations) {\n            if (value === null || value && (valueType === \"string\" || valueType === \"number\")) {\n                result[key] = value;\n            }\n        } else if (valueType === typeof result[key]) {\n            result[key] = key === \"rotate\" ? value % 4 : value;\n        }\n    }\n    return result;\n}\nconst separator = /[\\s,]+/;\nfunction flipFromString(custom, flip) {\n    flip.split(separator).forEach((str)=>{\n        const value = str.trim();\n        switch(value){\n            case \"horizontal\":\n                custom.hFlip = true;\n                break;\n            case \"vertical\":\n                custom.vFlip = true;\n                break;\n        }\n    });\n}\nfunction rotateFromString(value, defaultValue = 0) {\n    const units = value.replace(/^-?[0-9.]*/, \"\");\n    function cleanup(value2) {\n        while(value2 < 0){\n            value2 += 4;\n        }\n        return value2 % 4;\n    }\n    if (units === \"\") {\n        const num = parseInt(value);\n        return isNaN(num) ? 0 : cleanup(num);\n    } else if (units !== value) {\n        let split = 0;\n        switch(units){\n            case \"%\":\n                split = 25;\n                break;\n            case \"deg\":\n                split = 90;\n        }\n        if (split) {\n            let num = parseFloat(value.slice(0, value.length - units.length));\n            if (isNaN(num)) {\n                return 0;\n            }\n            num = num / split;\n            return num % 1 === 0 ? cleanup(num) : 0;\n        }\n    }\n    return defaultValue;\n}\nfunction iconToHTML(body, attributes) {\n    let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n    for(const attr in attributes){\n        renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n    }\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\nfunction encodeSVGforURL(svg) {\n    return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction svgToData(svg) {\n    return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n    return 'url(\"' + svgToData(svg) + '\")';\n}\nlet policy;\nfunction createPolicy() {\n    try {\n        policy = window.trustedTypes.createPolicy(\"iconify\", {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            createHTML: (s)=>s\n        });\n    } catch (err) {\n        policy = null;\n    }\n}\nfunction cleanUpInnerHTML(html) {\n    if (policy === void 0) {\n        createPolicy();\n    }\n    return policy ? policy.createHTML(html) : html;\n}\nconst defaultExtendedIconCustomisations = {\n    ...defaultIconCustomisations,\n    inline: false\n};\n/**\n * Default SVG attributes\n */ const svgDefaults = {\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"xmlnsXlink\": \"http://www.w3.org/1999/xlink\",\n    \"aria-hidden\": true,\n    \"role\": \"img\"\n};\n/**\n * Style modes\n */ const commonProps = {\n    display: \"inline-block\"\n};\nconst monotoneProps = {\n    backgroundColor: \"currentColor\"\n};\nconst coloredProps = {\n    backgroundColor: \"transparent\"\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    Image: \"var(--svg)\",\n    Repeat: \"no-repeat\",\n    Size: \"100% 100%\"\n};\nconst propsToAddTo = {\n    WebkitMask: monotoneProps,\n    mask: monotoneProps,\n    background: coloredProps\n};\nfor(const prefix in propsToAddTo){\n    const list = propsToAddTo[prefix];\n    for(const prop in propsToAdd){\n        list[prefix + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Default values for customisations for inline icon\n */ const inlineDefaults = {\n    ...defaultExtendedIconCustomisations,\n    inline: true\n};\n/**\n * Fix size: add 'px' to numbers\n */ function fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? \"px\" : \"\");\n}\n/**\n * Render icon\n */ const render = (// Icon must be validated before calling this function\nicon, // Partial properties\nprops, // True if icon should have vertical-align added\ninline, // Optional reference for SVG/SPAN, extracted by React.forwardRef()\nref)=>{\n    // Get default properties\n    const defaultProps = inline ? inlineDefaults : defaultExtendedIconCustomisations;\n    // Get all customisations\n    const customisations = mergeCustomisations(defaultProps, props);\n    // Check mode\n    const mode = props.mode || \"svg\";\n    // Create style\n    const style = {};\n    const customStyle = props.style || {};\n    // Create SVG component properties\n    const componentProps = {\n        ...mode === \"svg\" ? svgDefaults : {},\n        ref\n    };\n    // Get element properties\n    for(let key in props){\n        const value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch(key){\n            // Properties to ignore\n            case \"icon\":\n            case \"style\":\n            case \"children\":\n            case \"onLoad\":\n            case \"mode\":\n            case \"_ref\":\n            case \"_inline\":\n                break;\n            // Boolean attributes\n            case \"inline\":\n            case \"hFlip\":\n            case \"vFlip\":\n                customisations[key] = value === true || value === \"true\" || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case \"flip\":\n                if (typeof value === \"string\") {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style\n            case \"color\":\n                style.color = value;\n                break;\n            // Rotation as string\n            case \"rotate\":\n                if (typeof value === \"string\") {\n                    customisations[key] = rotateFromString(value);\n                } else if (typeof value === \"number\") {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case \"ariaHidden\":\n            case \"aria-hidden\":\n                if (value !== true && value !== \"true\") {\n                    delete componentProps[\"aria-hidden\"];\n                }\n                break;\n            // Copy missing property if it does not exist in customisations\n            default:\n                if (defaultProps[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    const item = iconToSVG(icon, customisations);\n    const renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        style.verticalAlign = \"-0.125em\";\n    }\n    if (mode === \"svg\") {\n        // Add style\n        componentProps.style = {\n            ...style,\n            ...customStyle\n        };\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        let localCounter = 0;\n        let id = props.id;\n        if (typeof id === \"string\") {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, \"_\");\n        }\n        // Add icon stuff\n        componentProps.dangerouslySetInnerHTML = {\n            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? ()=>id + \"ID\" + localCounter++ : \"iconifyReact\"))\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", componentProps);\n    }\n    // Render <span> with style\n    const { body, width, height } = icon;\n    const useMask = mode === \"mask\" || (mode === \"bg\" ? false : body.indexOf(\"currentColor\") !== -1);\n    // Generate SVG\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: width + \"\",\n        height: height + \"\"\n    });\n    // Generate style\n    componentProps.style = {\n        ...style,\n        \"--svg\": svgToURL(html),\n        \"width\": fixSize(renderAttribs.width),\n        \"height\": fixSize(renderAttribs.height),\n        ...commonProps,\n        ...useMask ? monotoneProps : coloredProps,\n        ...customStyle\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", componentProps);\n};\n/**\n * Enable cache\n */ function enableCache(storage) {\n    toggleBrowserCache(storage, true);\n}\n/**\n * Disable cache\n */ function disableCache(storage) {\n    toggleBrowserCache(storage, false);\n}\n/**\n * Initialise stuff\n */ // Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule(\"\", fetchAPIModule);\n/**\n * Browser stuff\n */ if (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {}\nclass IconComponent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            // Render placeholder before component is mounted\n            icon: null\n        };\n    }\n    /**\n     * Abort loading icon\n     */ _abortLoading() {\n        if (this._loading) {\n            this._loading.abort();\n            this._loading = null;\n        }\n    }\n    /**\n     * Update state\n     */ _setData(icon) {\n        if (this.state.icon !== icon) {\n            this.setState({\n                icon\n            });\n        }\n    }\n    /**\n     * Check if icon should be loaded\n     */ _checkIcon(changed) {\n        const state = this.state;\n        const icon = this.props.icon;\n        // Icon is an object\n        if (typeof icon === \"object\" && icon !== null && typeof icon.body === \"string\") {\n            // Stop loading\n            this._icon = \"\";\n            this._abortLoading();\n            if (changed || state.icon === null) {\n                // Set data if it was changed\n                this._setData({\n                    data: icon\n                });\n            }\n            return;\n        }\n        // Invalid icon?\n        let iconName;\n        if (typeof icon !== \"string\" || (iconName = stringToIcon(icon, false, true)) === null) {\n            this._abortLoading();\n            this._setData(null);\n            return;\n        }\n        // Load icon\n        const data = getIconData(iconName);\n        if (!data) {\n            // Icon data is not available\n            if (!this._loading || this._loading.name !== icon) {\n                // New icon to load\n                this._abortLoading();\n                this._icon = \"\";\n                this._setData(null);\n                if (data !== null) {\n                    // Icon was not loaded\n                    this._loading = {\n                        name: icon,\n                        abort: loadIcons([\n                            iconName\n                        ], this._checkIcon.bind(this, false))\n                    };\n                }\n            }\n            return;\n        }\n        // Icon data is available\n        if (this._icon !== icon || state.icon === null) {\n            // New icon or icon has been loaded\n            this._abortLoading();\n            this._icon = icon;\n            // Add classes\n            const classes = [\n                \"iconify\"\n            ];\n            if (iconName.prefix !== \"\") {\n                classes.push(\"iconify--\" + iconName.prefix);\n            }\n            if (iconName.provider !== \"\") {\n                classes.push(\"iconify--\" + iconName.provider);\n            }\n            // Set data\n            this._setData({\n                data,\n                classes\n            });\n            if (this.props.onLoad) {\n                this.props.onLoad(icon);\n            }\n        }\n    }\n    /**\n     * Component mounted\n     */ componentDidMount() {\n        this._checkIcon(false);\n    }\n    /**\n     * Component updated\n     */ componentDidUpdate(oldProps) {\n        if (oldProps.icon !== this.props.icon) {\n            this._checkIcon(true);\n        }\n    }\n    /**\n     * Abort loading\n     */ componentWillUnmount() {\n        this._abortLoading();\n    }\n    /**\n     * Render\n     */ render() {\n        const props = this.props;\n        const icon = this.state.icon;\n        if (icon === null) {\n            // Render placeholder\n            return props.children ? props.children : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {});\n        }\n        // Add classes\n        let newProps = props;\n        if (icon.classes) {\n            newProps = {\n                ...props,\n                className: (typeof props.className === \"string\" ? props.className + \" \" : \"\") + icon.classes.join(\" \")\n            };\n        }\n        // Render icon\n        return render({\n            ...defaultIconProps,\n            ...icon.data\n        }, newProps, props._inline, props._ref);\n    }\n}\n/**\n * Block icon\n *\n * @param props - Component properties\n */ const Icon = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Icon(props, ref) {\n    const newProps = {\n        ...props,\n        _ref: ref,\n        _inline: false\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(IconComponent, newProps);\n});\n/**\n * Inline icon (has negative verticalAlign that makes it behave like icon font)\n *\n * @param props - Component properties\n */ const InlineIcon = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function InlineIcon(props, ref) {\n    const newProps = {\n        ...props,\n        _ref: ref,\n        _inline: true\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(IconComponent, newProps);\n});\n/**\n * Internal API\n */ const _api = {\n    getAPIConfig,\n    setAPIModule,\n    sendAPIQuery,\n    setFetch,\n    getFetch,\n    listAPIProviders\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGljb25pZnkvcmVhY3QvZGlzdC9pY29uaWZ5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUUxQixNQUFNQyxnQkFBZ0I7QUFDdEIsTUFBTUMsZUFBZSxDQUFDQyxPQUFPQyxVQUFVQyxpQkFBaUJDLFdBQVcsRUFBRTtJQUNuRSxNQUFNQyxpQkFBaUJKLE1BQU1LLEtBQUssQ0FBQztJQUNuQyxJQUFJTCxNQUFNTSxLQUFLLENBQUMsR0FBRyxPQUFPLEtBQUs7UUFDN0IsSUFBSUYsZUFBZUcsTUFBTSxHQUFHLEtBQUtILGVBQWVHLE1BQU0sR0FBRyxHQUFHO1lBQzFELE9BQU87UUFDVDtRQUNBSixXQUFXQyxlQUFlSSxLQUFLLEdBQUdGLEtBQUssQ0FBQztJQUMxQztJQUNBLElBQUlGLGVBQWVHLE1BQU0sR0FBRyxLQUFLLENBQUNILGVBQWVHLE1BQU0sRUFBRTtRQUN2RCxPQUFPO0lBQ1Q7SUFDQSxJQUFJSCxlQUFlRyxNQUFNLEdBQUcsR0FBRztRQUM3QixNQUFNRSxRQUFRTCxlQUFlTSxHQUFHO1FBQ2hDLE1BQU1DLFNBQVNQLGVBQWVNLEdBQUc7UUFDakMsTUFBTUUsU0FBUztZQUNiLHFEQUFxRDtZQUNyRFQsVUFBVUMsZUFBZUcsTUFBTSxHQUFHLElBQUlILGNBQWMsQ0FBQyxFQUFFLEdBQUdEO1lBQzFEUTtZQUNBRSxNQUFNSjtRQUNSO1FBQ0EsT0FBT1IsWUFBWSxDQUFDYSxpQkFBaUJGLFVBQVUsT0FBT0E7SUFDeEQ7SUFDQSxNQUFNQyxPQUFPVCxjQUFjLENBQUMsRUFBRTtJQUM5QixNQUFNVyxnQkFBZ0JGLEtBQUtSLEtBQUssQ0FBQztJQUNqQyxJQUFJVSxjQUFjUixNQUFNLEdBQUcsR0FBRztRQUM1QixNQUFNSyxTQUFTO1lBQ2JUO1lBQ0FRLFFBQVFJLGNBQWNQLEtBQUs7WUFDM0JLLE1BQU1FLGNBQWNDLElBQUksQ0FBQztRQUMzQjtRQUNBLE9BQU9mLFlBQVksQ0FBQ2Es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InNvdXJjZXMiOlsid2VicGFjazovL2VxdWlwLXZlbG8tZm9yLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AaWNvbmlmeS9yZWFjdC9kaXN0L2ljb25pZnkubWpzPzY1MDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgbWF0Y2hJY29uTmFtZSA9IC9eW2EtejAtOV0rKC1bYS16MC05XSspKiQvO1xuY29uc3Qgc3RyaW5nVG9JY29uID0gKHZhbHVlLCB2YWxpZGF0ZSwgYWxsb3dTaW1wbGVOYW1lLCBwcm92aWRlciA9IFwiXCIpID0+IHtcbiAgY29uc3QgY29sb25TZXBhcmF0ZWQgPSB2YWx1ZS5zcGxpdChcIjpcIik7XG4gIGlmICh2YWx1ZS5zbGljZSgwLCAxKSA9PT0gXCJAXCIpIHtcbiAgICBpZiAoY29sb25TZXBhcmF0ZWQubGVuZ3RoIDwgMiB8fCBjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcHJvdmlkZXIgPSBjb2xvblNlcGFyYXRlZC5zaGlmdCgpLnNsaWNlKDEpO1xuICB9XG4gIGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAzIHx8ICFjb2xvblNlcGFyYXRlZC5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5hbWUyID0gY29sb25TZXBhcmF0ZWQucG9wKCk7XG4gICAgY29uc3QgcHJlZml4ID0gY29sb25TZXBhcmF0ZWQucG9wKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgLy8gQWxsb3cgcHJvdmlkZXIgd2l0aG91dCAnQCc6IFwicHJvdmlkZXI6cHJlZml4Om5hbWVcIlxuICAgICAgcHJvdmlkZXI6IGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDAgPyBjb2xvblNlcGFyYXRlZFswXSA6IHByb3ZpZGVyLFxuICAgICAgcHJlZml4LFxuICAgICAgbmFtZTogbmFtZTJcbiAgICB9O1xuICAgIHJldHVybiB2YWxpZGF0ZSAmJiAhdmFsaWRhdGVJY29uTmFtZShyZXN1bHQpID8gbnVsbCA6IHJlc3VsdDtcbiAgfVxuICBjb25zdCBuYW1lID0gY29sb25TZXBhcmF0ZWRbMF07XG4gIGNvbnN0IGRhc2hTZXBhcmF0ZWQgPSBuYW1lLnNwbGl0KFwiLVwiKTtcbiAgaWYgKGRhc2hTZXBhcmF0ZWQubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgcHJlZml4OiBkYXNoU2VwYXJhdGVkLnNoaWZ0KCksXG4gICAgICBuYW1lOiBkYXNoU2VwYXJhdGVkLmpvaW4oXCItXCIpXG4gICAgfTtcbiAgICByZXR1cm4gdmFsaWRhdGUgJiYgIXZhbGlkYXRlSWNvbk5hbWUocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFsbG93U2ltcGxlTmFtZSAmJiBwcm92aWRlciA9PT0gXCJcIikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb25OYW1lKHJlc3VsdCwgYWxsb3dTaW1wbGVOYW1lKSA/IG51bGwgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgdmFsaWRhdGVJY29uTmFtZSA9IChpY29uLCBhbGxvd1NpbXBsZU5hbWUpID0+IHtcbiAgaWYgKCFpY29uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhISgoaWNvbi5wcm92aWRlciA9PT0gXCJcIiB8fCBpY29uLnByb3ZpZGVyLm1hdGNoKG1hdGNoSWNvbk5hbWUpKSAmJiAoYWxsb3dTaW1wbGVOYW1lICYmIGljb24ucHJlZml4ID09PSBcIlwiIHx8IGljb24ucHJlZml4Lm1hdGNoKG1hdGNoSWNvbk5hbWUpKSAmJiBpY29uLm5hbWUubWF0Y2gobWF0Y2hJY29uTmFtZSkpO1xufTtcblxuY29uc3QgZGVmYXVsdEljb25EaW1lbnNpb25zID0gT2JqZWN0LmZyZWV6ZShcbiAge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHdpZHRoOiAxNixcbiAgICBoZWlnaHQ6IDE2XG4gIH1cbik7XG5jb25zdCBkZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICByb3RhdGU6IDAsXG4gIHZGbGlwOiBmYWxzZSxcbiAgaEZsaXA6IGZhbHNlXG59KTtcbmNvbnN0IGRlZmF1bHRJY29uUHJvcHMgPSBPYmplY3QuZnJlZXplKHtcbiAgLi4uZGVmYXVsdEljb25EaW1lbnNpb25zLFxuICAuLi5kZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9uc1xufSk7XG5jb25zdCBkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHMgPSBPYmplY3QuZnJlZXplKHtcbiAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgYm9keTogXCJcIixcbiAgaGlkZGVuOiBmYWxzZVxufSk7XG5cbmZ1bmN0aW9uIG1lcmdlSWNvblRyYW5zZm9ybWF0aW9ucyhvYmoxLCBvYmoyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBpZiAoIW9iajEuaEZsaXAgIT09ICFvYmoyLmhGbGlwKSB7XG4gICAgcmVzdWx0LmhGbGlwID0gdHJ1ZTtcbiAgfVxuICBpZiAoIW9iajEudkZsaXAgIT09ICFvYmoyLnZGbGlwKSB7XG4gICAgcmVzdWx0LnZGbGlwID0gdHJ1ZTtcbiAgfVxuICBjb25zdCByb3RhdGUgPSAoKG9iajEucm90YXRlIHx8IDApICsgKG9iajIucm90YXRlIHx8IDApKSAlIDQ7XG4gIGlmIChyb3RhdGUpIHtcbiAgICByZXN1bHQucm90YXRlID0gcm90YXRlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSWNvbkRhdGEocGFyZW50LCBjaGlsZCkge1xuICBjb25zdCByZXN1bHQgPSBtZXJnZUljb25UcmFuc2Zvcm1hdGlvbnMocGFyZW50LCBjaGlsZCk7XG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wcykge1xuICAgIGlmIChrZXkgaW4gZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnMpIHtcbiAgICAgIGlmIChrZXkgaW4gcGFyZW50ICYmICEoa2V5IGluIHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5IGluIGNoaWxkKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGNoaWxkW2tleV07XG4gICAgfSBlbHNlIGlmIChrZXkgaW4gcGFyZW50KSB7XG4gICAgICByZXN1bHRba2V5XSA9IHBhcmVudFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRJY29uc1RyZWUoZGF0YSwgbmFtZXMpIHtcbiAgY29uc3QgaWNvbnMgPSBkYXRhLmljb25zO1xuICBjb25zdCBhbGlhc2VzID0gZGF0YS5hbGlhc2VzIHx8IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCByZXNvbHZlZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmdW5jdGlvbiByZXNvbHZlKG5hbWUpIHtcbiAgICBpZiAoaWNvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiByZXNvbHZlZFtuYW1lXSA9IFtdO1xuICAgIH1cbiAgICBpZiAoIShuYW1lIGluIHJlc29sdmVkKSkge1xuICAgICAgcmVzb2x2ZWRbbmFtZV0gPSBudWxsO1xuICAgICAgY29uc3QgcGFyZW50ID0gYWxpYXNlc1tuYW1lXSAmJiBhbGlhc2VzW25hbWVdLnBhcmVudDtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyZW50ICYmIHJlc29sdmUocGFyZW50KTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlZFtuYW1lXSA9IFtwYXJlbnRdLmNvbmNhdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZFtuYW1lXTtcbiAgfVxuICAobmFtZXMgfHwgT2JqZWN0LmtleXMoaWNvbnMpLmNvbmNhdChPYmplY3Qua2V5cyhhbGlhc2VzKSkpLmZvckVhY2gocmVzb2x2ZSk7XG4gIHJldHVybiByZXNvbHZlZDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJY29uRGF0YShkYXRhLCBuYW1lLCB0cmVlKSB7XG4gIGNvbnN0IGljb25zID0gZGF0YS5pY29ucztcbiAgY29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IGN1cnJlbnRQcm9wcyA9IHt9O1xuICBmdW5jdGlvbiBwYXJzZShuYW1lMikge1xuICAgIGN1cnJlbnRQcm9wcyA9IG1lcmdlSWNvbkRhdGEoXG4gICAgICBpY29uc1tuYW1lMl0gfHwgYWxpYXNlc1tuYW1lMl0sXG4gICAgICBjdXJyZW50UHJvcHNcbiAgICApO1xuICB9XG4gIHBhcnNlKG5hbWUpO1xuICB0cmVlLmZvckVhY2gocGFyc2UpO1xuICByZXR1cm4gbWVyZ2VJY29uRGF0YShkYXRhLCBjdXJyZW50UHJvcHMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUljb25TZXQoZGF0YSwgY2FsbGJhY2spIHtcbiAgY29uc3QgbmFtZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBkYXRhLmljb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG5hbWVzO1xuICB9XG4gIGlmIChkYXRhLm5vdF9mb3VuZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgZGF0YS5ub3RfZm91bmQuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY2FsbGJhY2sobmFtZSwgbnVsbCk7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHRyZWUgPSBnZXRJY29uc1RyZWUoZGF0YSk7XG4gIGZvciAoY29uc3QgbmFtZSBpbiB0cmVlKSB7XG4gICAgY29uc3QgaXRlbSA9IHRyZWVbbmFtZV07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGNhbGxiYWNrKG5hbWUsIGludGVybmFsR2V0SWNvbkRhdGEoZGF0YSwgbmFtZSwgaXRlbSkpO1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5hbWVzO1xufVxuXG5jb25zdCBvcHRpb25hbFByb3BlcnR5RGVmYXVsdHMgPSB7XG4gIHByb3ZpZGVyOiBcIlwiLFxuICBhbGlhc2VzOiB7fSxcbiAgbm90X2ZvdW5kOiB7fSxcbiAgLi4uZGVmYXVsdEljb25EaW1lbnNpb25zXG59O1xuZnVuY3Rpb24gY2hlY2tPcHRpb25hbFByb3BzKGl0ZW0sIGRlZmF1bHRzKSB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBkZWZhdWx0cykge1xuICAgIGlmIChwcm9wIGluIGl0ZW0gJiYgdHlwZW9mIGl0ZW1bcHJvcF0gIT09IHR5cGVvZiBkZWZhdWx0c1twcm9wXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHF1aWNrbHlWYWxpZGF0ZUljb25TZXQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBvYmo7XG4gIGlmICh0eXBlb2YgZGF0YS5wcmVmaXggIT09IFwic3RyaW5nXCIgfHwgIW9iai5pY29ucyB8fCB0eXBlb2Ygb2JqLmljb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFjaGVja09wdGlvbmFsUHJvcHMob2JqLCBvcHRpb25hbFByb3BlcnR5RGVmYXVsdHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaWNvbnMgPSBkYXRhLmljb25zO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gaWNvbnMpIHtcbiAgICBjb25zdCBpY29uID0gaWNvbnNbbmFtZV07XG4gICAgaWYgKCFuYW1lLm1hdGNoKG1hdGNoSWNvbk5hbWUpIHx8IHR5cGVvZiBpY29uLmJvZHkgIT09IFwic3RyaW5nXCIgfHwgIWNoZWNrT3B0aW9uYWxQcm9wcyhcbiAgICAgIGljb24sXG4gICAgICBkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHNcbiAgICApKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcyB8fCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBuYW1lIGluIGFsaWFzZXMpIHtcbiAgICBjb25zdCBpY29uID0gYWxpYXNlc1tuYW1lXTtcbiAgICBjb25zdCBwYXJlbnQgPSBpY29uLnBhcmVudDtcbiAgICBpZiAoIW5hbWUubWF0Y2gobWF0Y2hJY29uTmFtZSkgfHwgdHlwZW9mIHBhcmVudCAhPT0gXCJzdHJpbmdcIiB8fCAhaWNvbnNbcGFyZW50XSAmJiAhYWxpYXNlc1twYXJlbnRdIHx8ICFjaGVja09wdGlvbmFsUHJvcHMoXG4gICAgICBpY29uLFxuICAgICAgZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzXG4gICAgKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5jb25zdCBkYXRhU3RvcmFnZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gbmV3U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSB7XG4gIHJldHVybiB7XG4gICAgcHJvdmlkZXIsXG4gICAgcHJlZml4LFxuICAgIGljb25zOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBtaXNzaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpIHtcbiAgY29uc3QgcHJvdmlkZXJTdG9yYWdlID0gZGF0YVN0b3JhZ2VbcHJvdmlkZXJdIHx8IChkYXRhU3RvcmFnZVtwcm92aWRlcl0gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIHJldHVybiBwcm92aWRlclN0b3JhZ2VbcHJlZml4XSB8fCAocHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gPSBuZXdTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpKTtcbn1cbmZ1bmN0aW9uIGFkZEljb25TZXQoc3RvcmFnZSwgZGF0YSkge1xuICBpZiAoIXF1aWNrbHlWYWxpZGF0ZUljb25TZXQoZGF0YSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHBhcnNlSWNvblNldChkYXRhLCAobmFtZSwgaWNvbikgPT4ge1xuICAgIGlmIChpY29uKSB7XG4gICAgICBzdG9yYWdlLmljb25zW25hbWVdID0gaWNvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmFnZS5taXNzaW5nLmFkZChuYW1lKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkSWNvblRvU3RvcmFnZShzdG9yYWdlLCBuYW1lLCBpY29uKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBpY29uLmJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN0b3JhZ2UuaWNvbnNbbmFtZV0gPSB7IC4uLmljb24gfTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbGlzdEljb25zKHByb3ZpZGVyLCBwcmVmaXgpIHtcbiAgbGV0IGFsbEljb25zID0gW107XG4gIGNvbnN0IHByb3ZpZGVycyA9IHR5cGVvZiBwcm92aWRlciA9PT0gXCJzdHJpbmdcIiA/IFtwcm92aWRlcl0gOiBPYmplY3Qua2V5cyhkYXRhU3RvcmFnZSk7XG4gIHByb3ZpZGVycy5mb3JFYWNoKChwcm92aWRlcjIpID0+IHtcbiAgICBjb25zdCBwcmVmaXhlcyA9IHR5cGVvZiBwcm92aWRlcjIgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHByZWZpeCA9PT0gXCJzdHJpbmdcIiA/IFtwcmVmaXhdIDogT2JqZWN0LmtleXMoZGF0YVN0b3JhZ2VbcHJvdmlkZXIyXSB8fCB7fSk7XG4gICAgcHJlZml4ZXMuZm9yRWFjaCgocHJlZml4MikgPT4ge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UocHJvdmlkZXIyLCBwcmVmaXgyKTtcbiAgICAgIGFsbEljb25zID0gYWxsSWNvbnMuY29uY2F0KFxuICAgICAgICBPYmplY3Qua2V5cyhzdG9yYWdlLmljb25zKS5tYXAoXG4gICAgICAgICAgKG5hbWUpID0+IChwcm92aWRlcjIgIT09IFwiXCIgPyBcIkBcIiArIHByb3ZpZGVyMiArIFwiOlwiIDogXCJcIikgKyBwcmVmaXgyICsgXCI6XCIgKyBuYW1lXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gYWxsSWNvbnM7XG59XG5cbmxldCBzaW1wbGVOYW1lcyA9IGZhbHNlO1xuZnVuY3Rpb24gYWxsb3dTaW1wbGVOYW1lcyhhbGxvdykge1xuICBpZiAodHlwZW9mIGFsbG93ID09PSBcImJvb2xlYW5cIikge1xuICAgIHNpbXBsZU5hbWVzID0gYWxsb3c7XG4gIH1cbiAgcmV0dXJuIHNpbXBsZU5hbWVzO1xufVxuZnVuY3Rpb24gZ2V0SWNvbkRhdGEobmFtZSkge1xuICBjb25zdCBpY29uID0gdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24obmFtZSwgdHJ1ZSwgc2ltcGxlTmFtZXMpIDogbmFtZTtcbiAgaWYgKGljb24pIHtcbiAgICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShpY29uLnByb3ZpZGVyLCBpY29uLnByZWZpeCk7XG4gICAgY29uc3QgaWNvbk5hbWUgPSBpY29uLm5hbWU7XG4gICAgcmV0dXJuIHN0b3JhZ2UuaWNvbnNbaWNvbk5hbWVdIHx8IChzdG9yYWdlLm1pc3NpbmcuaGFzKGljb25OYW1lKSA/IG51bGwgOiB2b2lkIDApO1xuICB9XG59XG5mdW5jdGlvbiBhZGRJY29uKG5hbWUsIGRhdGEpIHtcbiAgY29uc3QgaWNvbiA9IHN0cmluZ1RvSWNvbihuYW1lLCB0cnVlLCBzaW1wbGVOYW1lcyk7XG4gIGlmICghaWNvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShpY29uLnByb3ZpZGVyLCBpY29uLnByZWZpeCk7XG4gIHJldHVybiBhZGRJY29uVG9TdG9yYWdlKHN0b3JhZ2UsIGljb24ubmFtZSwgZGF0YSk7XG59XG5mdW5jdGlvbiBhZGRDb2xsZWN0aW9uKGRhdGEsIHByb3ZpZGVyKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcHJvdmlkZXIgPSBkYXRhLnByb3ZpZGVyIHx8IFwiXCI7XG4gIH1cbiAgaWYgKHNpbXBsZU5hbWVzICYmICFwcm92aWRlciAmJiAhZGF0YS5wcmVmaXgpIHtcbiAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICBpZiAocXVpY2tseVZhbGlkYXRlSWNvblNldChkYXRhKSkge1xuICAgICAgZGF0YS5wcmVmaXggPSBcIlwiO1xuICAgICAgcGFyc2VJY29uU2V0KGRhdGEsIChuYW1lLCBpY29uKSA9PiB7XG4gICAgICAgIGlmIChpY29uICYmIGFkZEljb24obmFtZSwgaWNvbikpIHtcbiAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYWRkZWQ7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gZGF0YS5wcmVmaXg7XG4gIGlmICghdmFsaWRhdGVJY29uTmFtZSh7XG4gICAgcHJvdmlkZXIsXG4gICAgcHJlZml4LFxuICAgIG5hbWU6IFwiYVwiXG4gIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpO1xuICByZXR1cm4gISFhZGRJY29uU2V0KHN0b3JhZ2UsIGRhdGEpO1xufVxuZnVuY3Rpb24gaWNvbkV4aXN0cyhuYW1lKSB7XG4gIHJldHVybiAhIWdldEljb25EYXRhKG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0SWNvbihuYW1lKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldEljb25EYXRhKG5hbWUpO1xuICByZXR1cm4gcmVzdWx0ID8ge1xuICAgIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gICAgLi4ucmVzdWx0XG4gIH0gOiBudWxsO1xufVxuXG5jb25zdCBkZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsXG59KTtcbmNvbnN0IGRlZmF1bHRJY29uQ3VzdG9taXNhdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgLy8gRGltZW5zaW9uc1xuICAuLi5kZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucyxcbiAgLy8gVHJhbnNmb3JtYXRpb25zXG4gIC4uLmRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zXG59KTtcblxuY29uc3QgdW5pdHNTcGxpdCA9IC8oLT9bMC05Ll0qWzAtOV0rWzAtOS5dKikvZztcbmNvbnN0IHVuaXRzVGVzdCA9IC9eLT9bMC05Ll0qWzAtOV0rWzAtOS5dKiQvZztcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpemUoc2l6ZSwgcmF0aW8sIHByZWNpc2lvbikge1xuICBpZiAocmF0aW8gPT09IDEpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMTAwO1xuICBpZiAodHlwZW9mIHNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHNpemUgKiByYXRpbyAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgY29uc3Qgb2xkUGFydHMgPSBzaXplLnNwbGl0KHVuaXRzU3BsaXQpO1xuICBpZiAob2xkUGFydHMgPT09IG51bGwgfHwgIW9sZFBhcnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGNvbnN0IG5ld1BhcnRzID0gW107XG4gIGxldCBjb2RlID0gb2xkUGFydHMuc2hpZnQoKTtcbiAgbGV0IGlzTnVtYmVyID0gdW5pdHNUZXN0LnRlc3QoY29kZSk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGlzTnVtYmVyKSB7XG4gICAgICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KGNvZGUpO1xuICAgICAgaWYgKGlzTmFOKG51bSkpIHtcbiAgICAgICAgbmV3UGFydHMucHVzaChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1BhcnRzLnB1c2goTWF0aC5jZWlsKG51bSAqIHJhdGlvICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BhcnRzLnB1c2goY29kZSk7XG4gICAgfVxuICAgIGNvZGUgPSBvbGRQYXJ0cy5zaGlmdCgpO1xuICAgIGlmIChjb2RlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBuZXdQYXJ0cy5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBpc051bWJlciA9ICFpc051bWJlcjtcbiAgfVxufVxuXG5jb25zdCBpc1Vuc2V0S2V5d29yZCA9ICh2YWx1ZSkgPT4gdmFsdWUgPT09IFwidW5zZXRcIiB8fCB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWx1ZSA9PT0gXCJub25lXCI7XG5mdW5jdGlvbiBpY29uVG9TVkcoaWNvbiwgY3VzdG9taXNhdGlvbnMpIHtcbiAgY29uc3QgZnVsbEljb24gPSB7XG4gICAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgICAuLi5pY29uXG4gIH07XG4gIGNvbnN0IGZ1bGxDdXN0b21pc2F0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0SWNvbkN1c3RvbWlzYXRpb25zLFxuICAgIC4uLmN1c3RvbWlzYXRpb25zXG4gIH07XG4gIGNvbnN0IGJveCA9IHtcbiAgICBsZWZ0OiBmdWxsSWNvbi5sZWZ0LFxuICAgIHRvcDogZnVsbEljb24udG9wLFxuICAgIHdpZHRoOiBmdWxsSWNvbi53aWR0aCxcbiAgICBoZWlnaHQ6IGZ1bGxJY29uLmhlaWdodFxuICB9O1xuICBsZXQgYm9keSA9IGZ1bGxJY29uLmJvZHk7XG4gIFtmdWxsSWNvbiwgZnVsbEN1c3RvbWlzYXRpb25zXS5mb3JFYWNoKChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGhGbGlwID0gcHJvcHMuaEZsaXA7XG4gICAgY29uc3QgdkZsaXAgPSBwcm9wcy52RmxpcDtcbiAgICBsZXQgcm90YXRpb24gPSBwcm9wcy5yb3RhdGU7XG4gICAgaWYgKGhGbGlwKSB7XG4gICAgICBpZiAodkZsaXApIHtcbiAgICAgICAgcm90YXRpb24gKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKFxuICAgICAgICAgIFwidHJhbnNsYXRlKFwiICsgKGJveC53aWR0aCArIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoMCAtIGJveC50b3ApLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgICAgICApO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcInNjYWxlKC0xIDEpXCIpO1xuICAgICAgICBib3gudG9wID0gYm94LmxlZnQgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodkZsaXApIHtcbiAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKFxuICAgICAgICBcInRyYW5zbGF0ZShcIiArICgwIC0gYm94LmxlZnQpLnRvU3RyaW5nKCkgKyBcIiBcIiArIChib3guaGVpZ2h0ICsgYm94LnRvcCkudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgICApO1xuICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2goXCJzY2FsZSgxIC0xKVwiKTtcbiAgICAgIGJveC50b3AgPSBib3gubGVmdCA9IDA7XG4gICAgfVxuICAgIGxldCB0ZW1wVmFsdWU7XG4gICAgaWYgKHJvdGF0aW9uIDwgMCkge1xuICAgICAgcm90YXRpb24gLT0gTWF0aC5mbG9vcihyb3RhdGlvbiAvIDQpICogNDtcbiAgICB9XG4gICAgcm90YXRpb24gPSByb3RhdGlvbiAlIDQ7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0ZW1wVmFsdWUgPSBib3guaGVpZ2h0IC8gMiArIGJveC50b3A7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9ucy51bnNoaWZ0KFxuICAgICAgICAgIFwicm90YXRlKDkwIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIiBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRyYW5zZm9ybWF0aW9ucy51bnNoaWZ0KFxuICAgICAgICAgIFwicm90YXRlKDE4MCBcIiArIChib3gud2lkdGggLyAyICsgYm94LmxlZnQpLnRvU3RyaW5nKCkgKyBcIiBcIiArIChib3guaGVpZ2h0IC8gMiArIGJveC50b3ApLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdGVtcFZhbHVlID0gYm94LndpZHRoIC8gMiArIGJveC5sZWZ0O1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSgtOTAgXCIgKyB0ZW1wVmFsdWUudG9TdHJpbmcoKSArIFwiIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHJvdGF0aW9uICUgMiA9PT0gMSkge1xuICAgICAgaWYgKGJveC5sZWZ0ICE9PSBib3gudG9wKSB7XG4gICAgICAgIHRlbXBWYWx1ZSA9IGJveC5sZWZ0O1xuICAgICAgICBib3gubGVmdCA9IGJveC50b3A7XG4gICAgICAgIGJveC50b3AgPSB0ZW1wVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoYm94LndpZHRoICE9PSBib3guaGVpZ2h0KSB7XG4gICAgICAgIHRlbXBWYWx1ZSA9IGJveC53aWR0aDtcbiAgICAgICAgYm94LndpZHRoID0gYm94LmhlaWdodDtcbiAgICAgICAgYm94LmhlaWdodCA9IHRlbXBWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGJvZHkgPSAnPGcgdHJhbnNmb3JtPVwiJyArIHRyYW5zZm9ybWF0aW9ucy5qb2luKFwiIFwiKSArICdcIj4nICsgYm9keSArIFwiPC9nPlwiO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGN1c3RvbWlzYXRpb25zV2lkdGggPSBmdWxsQ3VzdG9taXNhdGlvbnMud2lkdGg7XG4gIGNvbnN0IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID0gZnVsbEN1c3RvbWlzYXRpb25zLmhlaWdodDtcbiAgY29uc3QgYm94V2lkdGggPSBib3gud2lkdGg7XG4gIGNvbnN0IGJveEhlaWdodCA9IGJveC5oZWlnaHQ7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGhlaWdodDtcbiAgaWYgKGN1c3RvbWlzYXRpb25zV2lkdGggPT09IG51bGwpIHtcbiAgICBoZWlnaHQgPSBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gbnVsbCA/IFwiMWVtXCIgOiBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gXCJhdXRvXCIgPyBib3hIZWlnaHQgOiBjdXN0b21pc2F0aW9uc0hlaWdodDtcbiAgICB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoaGVpZ2h0LCBib3hXaWR0aCAvIGJveEhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSBjdXN0b21pc2F0aW9uc1dpZHRoID09PSBcImF1dG9cIiA/IGJveFdpZHRoIDogY3VzdG9taXNhdGlvbnNXaWR0aDtcbiAgICBoZWlnaHQgPSBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gbnVsbCA/IGNhbGN1bGF0ZVNpemUod2lkdGgsIGJveEhlaWdodCAvIGJveFdpZHRoKSA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0ID09PSBcImF1dG9cIiA/IGJveEhlaWdodCA6IGN1c3RvbWlzYXRpb25zSGVpZ2h0O1xuICB9XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3Qgc2V0QXR0ciA9IChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNVbnNldEtleXdvcmQodmFsdWUpKSB7XG4gICAgICBhdHRyaWJ1dGVzW3Byb3BdID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG4gIHNldEF0dHIoXCJ3aWR0aFwiLCB3aWR0aCk7XG4gIHNldEF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgYXR0cmlidXRlcy52aWV3Qm94ID0gYm94LmxlZnQudG9TdHJpbmcoKSArIFwiIFwiICsgYm94LnRvcC50b1N0cmluZygpICsgXCIgXCIgKyBib3hXaWR0aC50b1N0cmluZygpICsgXCIgXCIgKyBib3hIZWlnaHQudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGJvZHlcbiAgfTtcbn1cblxuY29uc3QgcmVnZXggPSAvXFxzaWQ9XCIoXFxTKylcIi9nO1xuY29uc3QgcmFuZG9tUHJlZml4ID0gXCJJY29uaWZ5SWRcIiArIERhdGUubm93KCkudG9TdHJpbmcoMTYpICsgKE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNiB8IDApLnRvU3RyaW5nKDE2KTtcbmxldCBjb3VudGVyID0gMDtcbmZ1bmN0aW9uIHJlcGxhY2VJRHMoYm9keSwgcHJlZml4ID0gcmFuZG9tUHJlZml4KSB7XG4gIGNvbnN0IGlkcyA9IFtdO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHJlZ2V4LmV4ZWMoYm9keSkpIHtcbiAgICBpZHMucHVzaChtYXRjaFsxXSk7XG4gIH1cbiAgaWYgKCFpZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgY29uc3Qgc3VmZml4ID0gXCJzdWZmaXhcIiArIChNYXRoLnJhbmRvbSgpICogMTY3NzcyMTYgfCBEYXRlLm5vdygpKS50b1N0cmluZygxNik7XG4gIGlkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgIGNvbnN0IG5ld0lEID0gdHlwZW9mIHByZWZpeCA9PT0gXCJmdW5jdGlvblwiID8gcHJlZml4KGlkKSA6IHByZWZpeCArIChjb3VudGVyKyspLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgZXNjYXBlZElEID0gaWQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xuICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoXG4gICAgICAvLyBBbGxvd2VkIGNoYXJhY3RlcnMgYmVmb3JlIGlkOiBbIztcIl1cbiAgICAgIC8vIEFsbG93ZWQgY2hhcmFjdGVycyBhZnRlciBpZDogWylcIl0sIC5bYS16XVxuICAgICAgbmV3IFJlZ0V4cCgnKFsjO1wiXSkoJyArIGVzY2FwZWRJRCArICcpKFtcIildfFxcXFwuW2Etel0pJywgXCJnXCIpLFxuICAgICAgXCIkMVwiICsgbmV3SUQgKyBzdWZmaXggKyBcIiQzXCJcbiAgICApO1xuICB9KTtcbiAgYm9keSA9IGJvZHkucmVwbGFjZShuZXcgUmVnRXhwKHN1ZmZpeCwgXCJnXCIpLCBcIlwiKTtcbiAgcmV0dXJuIGJvZHk7XG59XG5cbmNvbnN0IHN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIHNldEFQSU1vZHVsZShwcm92aWRlciwgaXRlbSkge1xuICBzdG9yYWdlW3Byb3ZpZGVyXSA9IGl0ZW07XG59XG5mdW5jdGlvbiBnZXRBUElNb2R1bGUocHJvdmlkZXIpIHtcbiAgcmV0dXJuIHN0b3JhZ2VbcHJvdmlkZXJdIHx8IHN0b3JhZ2VbXCJcIl07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFQSUNvbmZpZyhzb3VyY2UpIHtcbiAgbGV0IHJlc291cmNlcztcbiAgaWYgKHR5cGVvZiBzb3VyY2UucmVzb3VyY2VzID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmVzb3VyY2VzID0gW3NvdXJjZS5yZXNvdXJjZXNdO1xuICB9IGVsc2Uge1xuICAgIHJlc291cmNlcyA9IHNvdXJjZS5yZXNvdXJjZXM7XG4gICAgaWYgKCEocmVzb3VyY2VzIGluc3RhbmNlb2YgQXJyYXkpIHx8ICFyZXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC8vIEFQSSBob3N0c1xuICAgIHJlc291cmNlcyxcbiAgICAvLyBSb290IHBhdGhcbiAgICBwYXRoOiBzb3VyY2UucGF0aCB8fCBcIi9cIixcbiAgICAvLyBVUkwgbGVuZ3RoIGxpbWl0XG4gICAgbWF4VVJMOiBzb3VyY2UubWF4VVJMIHx8IDUwMCxcbiAgICAvLyBUaW1lb3V0IGJlZm9yZSBuZXh0IGhvc3QgaXMgdXNlZC5cbiAgICByb3RhdGU6IHNvdXJjZS5yb3RhdGUgfHwgNzUwLFxuICAgIC8vIFRpbWVvdXQgYmVmb3JlIGZhaWxpbmcgcXVlcnkuXG4gICAgdGltZW91dDogc291cmNlLnRpbWVvdXQgfHwgNWUzLFxuICAgIC8vIFJhbmRvbWlzZSBkZWZhdWx0IEFQSSBlbmQgcG9pbnQuXG4gICAgcmFuZG9tOiBzb3VyY2UucmFuZG9tID09PSB0cnVlLFxuICAgIC8vIFN0YXJ0IGluZGV4XG4gICAgaW5kZXg6IHNvdXJjZS5pbmRleCB8fCAwLFxuICAgIC8vIFJlY2VpdmUgZGF0YSBhZnRlciB0aW1lIG91dCAodXNlZCBpZiB0aW1lIG91dCBraWNrcyBpbiBmaXJzdCwgdGhlbiBBUEkgbW9kdWxlIHNlbmRzIGRhdGEgYW55d2F5KS5cbiAgICBkYXRhQWZ0ZXJUaW1lb3V0OiBzb3VyY2UuZGF0YUFmdGVyVGltZW91dCAhPT0gZmFsc2VcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGNvbmZpZ1N0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGZhbGxCYWNrQVBJU291cmNlcyA9IFtcbiAgXCJodHRwczovL2FwaS5zaW1wbGVzdmcuY29tXCIsXG4gIFwiaHR0cHM6Ly9hcGkudW5pc3ZnLmNvbVwiXG5dO1xuY29uc3QgZmFsbEJhY2tBUEkgPSBbXTtcbndoaWxlIChmYWxsQmFja0FQSVNvdXJjZXMubGVuZ3RoID4gMCkge1xuICBpZiAoZmFsbEJhY2tBUElTb3VyY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgIGZhbGxCYWNrQVBJLnB1c2goZmFsbEJhY2tBUElTb3VyY2VzLnNoaWZ0KCkpO1xuICB9IGVsc2Uge1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBmYWxsQmFja0FQSS5wdXNoKGZhbGxCYWNrQVBJU291cmNlcy5zaGlmdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsbEJhY2tBUEkucHVzaChmYWxsQmFja0FQSVNvdXJjZXMucG9wKCkpO1xuICAgIH1cbiAgfVxufVxuY29uZmlnU3RvcmFnZVtcIlwiXSA9IGNyZWF0ZUFQSUNvbmZpZyh7XG4gIHJlc291cmNlczogW1wiaHR0cHM6Ly9hcGkuaWNvbmlmeS5kZXNpZ25cIl0uY29uY2F0KGZhbGxCYWNrQVBJKVxufSk7XG5mdW5jdGlvbiBhZGRBUElQcm92aWRlcihwcm92aWRlciwgY3VzdG9tQ29uZmlnKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUFQSUNvbmZpZyhjdXN0b21Db25maWcpO1xuICBpZiAoY29uZmlnID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbmZpZ1N0b3JhZ2VbcHJvdmlkZXJdID0gY29uZmlnO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEFQSUNvbmZpZyhwcm92aWRlcikge1xuICByZXR1cm4gY29uZmlnU3RvcmFnZVtwcm92aWRlcl07XG59XG5mdW5jdGlvbiBsaXN0QVBJUHJvdmlkZXJzKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoY29uZmlnU3RvcmFnZSk7XG59XG5cbmNvbnN0IGRldGVjdEZldGNoID0gKCkgPT4ge1xuICBsZXQgY2FsbGJhY2s7XG4gIHRyeSB7XG4gICAgY2FsbGJhY2sgPSBmZXRjaDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG59O1xubGV0IGZldGNoTW9kdWxlID0gZGV0ZWN0RmV0Y2goKTtcbmZ1bmN0aW9uIHNldEZldGNoKGZldGNoMikge1xuICBmZXRjaE1vZHVsZSA9IGZldGNoMjtcbn1cbmZ1bmN0aW9uIGdldEZldGNoKCkge1xuICByZXR1cm4gZmV0Y2hNb2R1bGU7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVNYXhMZW5ndGgocHJvdmlkZXIsIHByZWZpeCkge1xuICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCByZXN1bHQ7XG4gIGlmICghY29uZmlnLm1heFVSTCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGV0IG1heEhvc3RMZW5ndGggPSAwO1xuICAgIGNvbmZpZy5yZXNvdXJjZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgaG9zdCA9IGl0ZW07XG4gICAgICBtYXhIb3N0TGVuZ3RoID0gTWF0aC5tYXgobWF4SG9zdExlbmd0aCwgaG9zdC5sZW5ndGgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHVybCA9IHByZWZpeCArIFwiLmpzb24/aWNvbnM9XCI7XG4gICAgcmVzdWx0ID0gY29uZmlnLm1heFVSTCAtIG1heEhvc3RMZW5ndGggLSBjb25maWcucGF0aC5sZW5ndGggLSB1cmwubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzaG91bGRBYm9ydChzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gNDA0O1xufVxuY29uc3QgcHJlcGFyZSA9IChwcm92aWRlciwgcHJlZml4LCBpY29ucykgPT4ge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGNvbnN0IG1heExlbmd0aCA9IGNhbGN1bGF0ZU1heExlbmd0aChwcm92aWRlciwgcHJlZml4KTtcbiAgY29uc3QgdHlwZSA9IFwiaWNvbnNcIjtcbiAgbGV0IGl0ZW0gPSB7XG4gICAgdHlwZSxcbiAgICBwcm92aWRlcixcbiAgICBwcmVmaXgsXG4gICAgaWNvbnM6IFtdXG4gIH07XG4gIGxldCBsZW5ndGggPSAwO1xuICBpY29ucy5mb3JFYWNoKChuYW1lLCBpbmRleCkgPT4ge1xuICAgIGxlbmd0aCArPSBuYW1lLmxlbmd0aCArIDE7XG4gICAgaWYgKGxlbmd0aCA+PSBtYXhMZW5ndGggJiYgaW5kZXggPiAwKSB7XG4gICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgcHJlZml4LFxuICAgICAgICBpY29uczogW11cbiAgICAgIH07XG4gICAgICBsZW5ndGggPSBuYW1lLmxlbmd0aDtcbiAgICB9XG4gICAgaXRlbS5pY29ucy5wdXNoKG5hbWUpO1xuICB9KTtcbiAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICByZXR1cm4gcmVzdWx0cztcbn07XG5mdW5jdGlvbiBnZXRQYXRoKHByb3ZpZGVyKSB7XG4gIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHJldHVybiBjb25maWcucGF0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiL1wiO1xufVxuY29uc3Qgc2VuZCA9IChob3N0LCBwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICghZmV0Y2hNb2R1bGUpIHtcbiAgICBjYWxsYmFjayhcImFib3J0XCIsIDQyNCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBwYXRoID0gZ2V0UGF0aChwYXJhbXMucHJvdmlkZXIpO1xuICBzd2l0Y2ggKHBhcmFtcy50eXBlKSB7XG4gICAgY2FzZSBcImljb25zXCI6IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHBhcmFtcy5wcmVmaXg7XG4gICAgICBjb25zdCBpY29ucyA9IHBhcmFtcy5pY29ucztcbiAgICAgIGNvbnN0IGljb25zTGlzdCA9IGljb25zLmpvaW4oXCIsXCIpO1xuICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGljb25zOiBpY29uc0xpc3RcbiAgICAgIH0pO1xuICAgICAgcGF0aCArPSBwcmVmaXggKyBcIi5qc29uP1wiICsgdXJsUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImN1c3RvbVwiOiB7XG4gICAgICBjb25zdCB1cmkgPSBwYXJhbXMudXJpO1xuICAgICAgcGF0aCArPSB1cmkuc2xpY2UoMCwgMSkgPT09IFwiL1wiID8gdXJpLnNsaWNlKDEpIDogdXJpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBjYWxsYmFjayhcImFib3J0XCIsIDQwMCk7XG4gICAgICByZXR1cm47XG4gIH1cbiAgbGV0IGRlZmF1bHRFcnJvciA9IDUwMztcbiAgZmV0Y2hNb2R1bGUoaG9zdCArIHBhdGgpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGlmIChzdGF0dXMgIT09IDIwMCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHNob3VsZEFib3J0KHN0YXR1cykgPyBcImFib3J0XCIgOiBcIm5leHRcIiwgc3RhdHVzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWZhdWx0RXJyb3IgPSA1MDE7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSkudGhlbigoZGF0YSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGRhdGEgPT09IDQwNCkge1xuICAgICAgICAgIGNhbGxiYWNrKFwiYWJvcnRcIiwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soXCJuZXh0XCIsIGRlZmF1bHRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKFwic3VjY2Vzc1wiLCBkYXRhKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2goKCkgPT4ge1xuICAgIGNhbGxiYWNrKFwibmV4dFwiLCBkZWZhdWx0RXJyb3IpO1xuICB9KTtcbn07XG5jb25zdCBmZXRjaEFQSU1vZHVsZSA9IHtcbiAgcHJlcGFyZSxcbiAgc2VuZFxufTtcblxuZnVuY3Rpb24gc29ydEljb25zKGljb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBsb2FkZWQ6IFtdLFxuICAgIG1pc3Npbmc6IFtdLFxuICAgIHBlbmRpbmc6IFtdXG4gIH07XG4gIGNvbnN0IHN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWNvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLnByb3ZpZGVyICE9PSBiLnByb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gYS5wcm92aWRlci5sb2NhbGVDb21wYXJlKGIucHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAoYS5wcmVmaXggIT09IGIucHJlZml4KSB7XG4gICAgICByZXR1cm4gYS5wcmVmaXgubG9jYWxlQ29tcGFyZShiLnByZWZpeCk7XG4gICAgfVxuICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICB9KTtcbiAgbGV0IGxhc3RJY29uID0ge1xuICAgIHByb3ZpZGVyOiBcIlwiLFxuICAgIHByZWZpeDogXCJcIixcbiAgICBuYW1lOiBcIlwiXG4gIH07XG4gIGljb25zLmZvckVhY2goKGljb24pID0+IHtcbiAgICBpZiAobGFzdEljb24ubmFtZSA9PT0gaWNvbi5uYW1lICYmIGxhc3RJY29uLnByZWZpeCA9PT0gaWNvbi5wcmVmaXggJiYgbGFzdEljb24ucHJvdmlkZXIgPT09IGljb24ucHJvdmlkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdEljb24gPSBpY29uO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gaWNvbi5wcm92aWRlcjtcbiAgICBjb25zdCBwcmVmaXggPSBpY29uLnByZWZpeDtcbiAgICBjb25zdCBuYW1lID0gaWNvbi5uYW1lO1xuICAgIGNvbnN0IHByb3ZpZGVyU3RvcmFnZSA9IHN0b3JhZ2VbcHJvdmlkZXJdIHx8IChzdG9yYWdlW3Byb3ZpZGVyXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBjb25zdCBsb2NhbFN0b3JhZ2UgPSBwcm92aWRlclN0b3JhZ2VbcHJlZml4XSB8fCAocHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpKTtcbiAgICBsZXQgbGlzdDtcbiAgICBpZiAobmFtZSBpbiBsb2NhbFN0b3JhZ2UuaWNvbnMpIHtcbiAgICAgIGxpc3QgPSByZXN1bHQubG9hZGVkO1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSBcIlwiIHx8IGxvY2FsU3RvcmFnZS5taXNzaW5nLmhhcyhuYW1lKSkge1xuICAgICAgbGlzdCA9IHJlc3VsdC5taXNzaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ID0gcmVzdWx0LnBlbmRpbmc7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIHByZWZpeCxcbiAgICAgIG5hbWVcbiAgICB9O1xuICAgIGxpc3QucHVzaChpdGVtKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNhbGxiYWNrKHN0b3JhZ2VzLCBpZCkge1xuICBzdG9yYWdlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcztcbiAgICBpZiAoaXRlbXMpIHtcbiAgICAgIHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzID0gaXRlbXMuZmlsdGVyKChyb3cpID0+IHJvdy5pZCAhPT0gaWQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWxsYmFja3Moc3RvcmFnZSkge1xuICBpZiAoIXN0b3JhZ2UucGVuZGluZ0NhbGxiYWNrc0ZsYWcpIHtcbiAgICBzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0b3JhZ2UucGVuZGluZ0NhbGxiYWNrc0ZsYWcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3MgPyBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcy5zbGljZSgwKSA6IFtdO1xuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGhhc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gc3RvcmFnZS5wcm92aWRlcjtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHN0b3JhZ2UucHJlZml4O1xuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpY29ucyA9IGl0ZW0uaWNvbnM7XG4gICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IGljb25zLnBlbmRpbmcubGVuZ3RoO1xuICAgICAgICBpY29ucy5wZW5kaW5nID0gaWNvbnMucGVuZGluZy5maWx0ZXIoKGljb24pID0+IHtcbiAgICAgICAgICBpZiAoaWNvbi5wcmVmaXggIT09IHByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5hbWUgPSBpY29uLm5hbWU7XG4gICAgICAgICAgaWYgKHN0b3JhZ2UuaWNvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGljb25zLmxvYWRlZC5wdXNoKHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yYWdlLm1pc3NpbmcuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBpY29ucy5taXNzaW5nLnB1c2goe1xuICAgICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGljb25zLnBlbmRpbmcubGVuZ3RoICE9PSBvbGRMZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWhhc1BlbmRpbmcpIHtcbiAgICAgICAgICAgIHJlbW92ZUNhbGxiYWNrKFtzdG9yYWdlXSwgaXRlbS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0uY2FsbGJhY2soXG4gICAgICAgICAgICBpY29ucy5sb2FkZWQuc2xpY2UoMCksXG4gICAgICAgICAgICBpY29ucy5taXNzaW5nLnNsaWNlKDApLFxuICAgICAgICAgICAgaWNvbnMucGVuZGluZy5zbGljZSgwKSxcbiAgICAgICAgICAgIGl0ZW0uYWJvcnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxubGV0IGlkQ291bnRlciA9IDA7XG5mdW5jdGlvbiBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBpY29ucywgcGVuZGluZ1NvdXJjZXMpIHtcbiAgY29uc3QgaWQgPSBpZENvdW50ZXIrKztcbiAgY29uc3QgYWJvcnQgPSByZW1vdmVDYWxsYmFjay5iaW5kKG51bGwsIHBlbmRpbmdTb3VyY2VzLCBpZCk7XG4gIGlmICghaWNvbnMucGVuZGluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWJvcnQ7XG4gIH1cbiAgY29uc3QgaXRlbSA9IHtcbiAgICBpZCxcbiAgICBpY29ucyxcbiAgICBjYWxsYmFjayxcbiAgICBhYm9ydFxuICB9O1xuICBwZW5kaW5nU291cmNlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgKHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzIHx8IChzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyA9IFtdKSkucHVzaChpdGVtKTtcbiAgfSk7XG4gIHJldHVybiBhYm9ydDtcbn1cblxuZnVuY3Rpb24gbGlzdFRvSWNvbnMobGlzdCwgdmFsaWRhdGUgPSB0cnVlLCBzaW1wbGVOYW1lcyA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBjb25zdCBpY29uID0gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaXRlbSwgdmFsaWRhdGUsIHNpbXBsZU5hbWVzKSA6IGl0ZW07XG4gICAgaWYgKGljb24pIHtcbiAgICAgIHJlc3VsdC5wdXNoKGljb24pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9jb25maWcudHNcbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICByZXNvdXJjZXM6IFtdLFxuICBpbmRleDogMCxcbiAgdGltZW91dDogMmUzLFxuICByb3RhdGU6IDc1MCxcbiAgcmFuZG9tOiBmYWxzZSxcbiAgZGF0YUFmdGVyVGltZW91dDogZmFsc2Vcbn07XG5cbi8vIHNyYy9xdWVyeS50c1xuZnVuY3Rpb24gc2VuZFF1ZXJ5KGNvbmZpZywgcGF5bG9hZCwgcXVlcnksIGRvbmUpIHtcbiAgY29uc3QgcmVzb3VyY2VzQ291bnQgPSBjb25maWcucmVzb3VyY2VzLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGNvbmZpZy5yYW5kb20gPyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZXNvdXJjZXNDb3VudCkgOiBjb25maWcuaW5kZXg7XG4gIGxldCByZXNvdXJjZXM7XG4gIGlmIChjb25maWcucmFuZG9tKSB7XG4gICAgbGV0IGxpc3QgPSBjb25maWcucmVzb3VyY2VzLnNsaWNlKDApO1xuICAgIHJlc291cmNlcyA9IFtdO1xuICAgIHdoaWxlIChsaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG5leHRJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxpc3QubGVuZ3RoKTtcbiAgICAgIHJlc291cmNlcy5wdXNoKGxpc3RbbmV4dEluZGV4XSk7XG4gICAgICBsaXN0ID0gbGlzdC5zbGljZSgwLCBuZXh0SW5kZXgpLmNvbmNhdChsaXN0LnNsaWNlKG5leHRJbmRleCArIDEpKTtcbiAgICB9XG4gICAgcmVzb3VyY2VzID0gcmVzb3VyY2VzLmNvbmNhdChsaXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXNvdXJjZXMgPSBjb25maWcucmVzb3VyY2VzLnNsaWNlKHN0YXJ0SW5kZXgpLmNvbmNhdChjb25maWcucmVzb3VyY2VzLnNsaWNlKDAsIHN0YXJ0SW5kZXgpKTtcbiAgfVxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICBsZXQgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gIGxldCBxdWVyaWVzU2VudCA9IDA7XG4gIGxldCBsYXN0RXJyb3I7XG4gIGxldCB0aW1lciA9IG51bGw7XG4gIGxldCBxdWV1ZSA9IFtdO1xuICBsZXQgZG9uZUNhbGxiYWNrcyA9IFtdO1xuICBpZiAodHlwZW9mIGRvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGRvbmVDYWxsYmFja3MucHVzaChkb25lKTtcbiAgfVxuICBmdW5jdGlvbiByZXNldFRpbWVyKCkge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICByZXNldFRpbWVyKCk7XG4gICAgcXVldWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICBpdGVtLnN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHF1ZXVlID0gW107XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrLCBvdmVyd3JpdGUpIHtcbiAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICBkb25lQ2FsbGJhY2tzID0gW107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZG9uZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UXVlcnlTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIHBheWxvYWQsXG4gICAgICBzdGF0dXMsXG4gICAgICBxdWVyaWVzU2VudCxcbiAgICAgIHF1ZXJpZXNQZW5kaW5nOiBxdWV1ZS5sZW5ndGgsXG4gICAgICBzdWJzY3JpYmUsXG4gICAgICBhYm9ydFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmFpbFF1ZXJ5KCkge1xuICAgIHN0YXR1cyA9IFwiZmFpbGVkXCI7XG4gICAgZG9uZUNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgY2FsbGJhY2sodm9pZCAwLCBsYXN0RXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gICAgcXVldWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICBpdGVtLnN0YXR1cyA9IFwiYWJvcnRlZFwiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHF1ZXVlID0gW107XG4gIH1cbiAgZnVuY3Rpb24gbW9kdWxlUmVzcG9uc2UoaXRlbSwgcmVzcG9uc2UsIGRhdGEpIHtcbiAgICBjb25zdCBpc0Vycm9yID0gcmVzcG9uc2UgIT09IFwic3VjY2Vzc1wiO1xuICAgIHF1ZXVlID0gcXVldWUuZmlsdGVyKChxdWV1ZWQpID0+IHF1ZXVlZCAhPT0gaXRlbSk7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICBpZiAoaXNFcnJvciB8fCAhY29uZmlnLmRhdGFBZnRlclRpbWVvdXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwb25zZSA9PT0gXCJhYm9ydFwiKSB7XG4gICAgICBsYXN0RXJyb3IgPSBkYXRhO1xuICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICBsYXN0RXJyb3IgPSBkYXRhO1xuICAgICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFyZXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlY05leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNldFRpbWVyKCk7XG4gICAgY2xlYXJRdWV1ZSgpO1xuICAgIGlmICghY29uZmlnLnJhbmRvbSkge1xuICAgICAgY29uc3QgaW5kZXggPSBjb25maWcucmVzb3VyY2VzLmluZGV4T2YoaXRlbS5yZXNvdXJjZSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4ICE9PSBjb25maWcuaW5kZXgpIHtcbiAgICAgICAgY29uZmlnLmluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXR1cyA9IFwiY29tcGxldGVkXCI7XG4gICAgZG9uZUNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZXhlY05leHQoKSB7XG4gICAgaWYgKHN0YXR1cyAhPT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzZXRUaW1lcigpO1xuICAgIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKHJlc291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZXNldFRpbWVyKCk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmYWlsUXVlcnkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHtcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICByZXNvdXJjZSxcbiAgICAgIGNhbGxiYWNrOiAoc3RhdHVzMiwgZGF0YSkgPT4ge1xuICAgICAgICBtb2R1bGVSZXNwb25zZShpdGVtLCBzdGF0dXMyLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgcXVlcmllc1NlbnQrKztcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZXhlY05leHQsIGNvbmZpZy5yb3RhdGUpO1xuICAgIHF1ZXJ5KHJlc291cmNlLCBwYXlsb2FkLCBpdGVtLmNhbGxiYWNrKTtcbiAgfVxuICBzZXRUaW1lb3V0KGV4ZWNOZXh0KTtcbiAgcmV0dXJuIGdldFF1ZXJ5U3RhdHVzO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGluaXRSZWR1bmRhbmN5KGNmZykge1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAuLi5jZmdcbiAgfTtcbiAgbGV0IHF1ZXJpZXMgPSBbXTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBxdWVyaWVzID0gcXVlcmllcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0oKS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKTtcbiAgfVxuICBmdW5jdGlvbiBxdWVyeShwYXlsb2FkLCBxdWVyeUNhbGxiYWNrLCBkb25lQ2FsbGJhY2spIHtcbiAgICBjb25zdCBxdWVyeTIgPSBzZW5kUXVlcnkoXG4gICAgICBjb25maWcsXG4gICAgICBwYXlsb2FkLFxuICAgICAgcXVlcnlDYWxsYmFjayxcbiAgICAgIChkYXRhLCBlcnJvcikgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGlmIChkb25lQ2FsbGJhY2spIHtcbiAgICAgICAgICBkb25lQ2FsbGJhY2soZGF0YSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBxdWVyaWVzLnB1c2gocXVlcnkyKTtcbiAgICByZXR1cm4gcXVlcnkyO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcXVlcmllcy5maW5kKCh2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlKTtcbiAgICB9KSB8fCBudWxsO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0ge1xuICAgIHF1ZXJ5LFxuICAgIGZpbmQsXG4gICAgc2V0SW5kZXg6IChpbmRleCkgPT4ge1xuICAgICAgY29uZmlnLmluZGV4ID0gaW5kZXg7XG4gICAgfSxcbiAgICBnZXRJbmRleDogKCkgPT4gY29uZmlnLmluZGV4LFxuICAgIGNsZWFudXBcbiAgfTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBlbXB0eUNhbGxiYWNrJDEoKSB7XG59XG5jb25zdCByZWR1bmRhbmN5Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGdldFJlZHVuZGFuY3lDYWNoZShwcm92aWRlcikge1xuICBpZiAoIXJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0pIHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlZHVuZGFuY3kgPSBpbml0UmVkdW5kYW5jeShjb25maWcpO1xuICAgIGNvbnN0IGNhY2hlZFJldW5kYW5jeSA9IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlZHVuZGFuY3lcbiAgICB9O1xuICAgIHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0gPSBjYWNoZWRSZXVuZGFuY3k7XG4gIH1cbiAgcmV0dXJuIHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl07XG59XG5mdW5jdGlvbiBzZW5kQVBJUXVlcnkodGFyZ2V0LCBxdWVyeSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlZHVuZGFuY3k7XG4gIGxldCBzZW5kO1xuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGFwaSA9IGdldEFQSU1vZHVsZSh0YXJnZXQpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICBjYWxsYmFjayh2b2lkIDAsIDQyNCk7XG4gICAgICByZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuICAgIH1cbiAgICBzZW5kID0gYXBpLnNlbmQ7XG4gICAgY29uc3QgY2FjaGVkID0gZ2V0UmVkdW5kYW5jeUNhY2hlKHRhcmdldCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmVkdW5kYW5jeSA9IGNhY2hlZC5yZWR1bmRhbmN5O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb25maWcgPSBjcmVhdGVBUElDb25maWcodGFyZ2V0KTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICByZWR1bmRhbmN5ID0gaW5pdFJlZHVuZGFuY3koY29uZmlnKTtcbiAgICAgIGNvbnN0IG1vZHVsZUtleSA9IHRhcmdldC5yZXNvdXJjZXMgPyB0YXJnZXQucmVzb3VyY2VzWzBdIDogXCJcIjtcbiAgICAgIGNvbnN0IGFwaSA9IGdldEFQSU1vZHVsZShtb2R1bGVLZXkpO1xuICAgICAgaWYgKGFwaSkge1xuICAgICAgICBzZW5kID0gYXBpLnNlbmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghcmVkdW5kYW5jeSB8fCAhc2VuZCkge1xuICAgIGNhbGxiYWNrKHZvaWQgMCwgNDI0KTtcbiAgICByZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuICB9XG4gIHJldHVybiByZWR1bmRhbmN5LnF1ZXJ5KHF1ZXJ5LCBzZW5kLCBjYWxsYmFjaykoKS5hYm9ydDtcbn1cblxuY29uc3QgYnJvd3NlckNhY2hlVmVyc2lvbiA9IFwiaWNvbmlmeTJcIjtcbmNvbnN0IGJyb3dzZXJDYWNoZVByZWZpeCA9IFwiaWNvbmlmeVwiO1xuY29uc3QgYnJvd3NlckNhY2hlQ291bnRLZXkgPSBicm93c2VyQ2FjaGVQcmVmaXggKyBcIi1jb3VudFwiO1xuY29uc3QgYnJvd3NlckNhY2hlVmVyc2lvbktleSA9IGJyb3dzZXJDYWNoZVByZWZpeCArIFwiLXZlcnNpb25cIjtcbmNvbnN0IGJyb3dzZXJTdG9yYWdlSG91ciA9IDM2ZTU7XG5jb25zdCBicm93c2VyU3RvcmFnZUNhY2hlRXhwaXJhdGlvbiA9IDE2ODtcblxuZnVuY3Rpb24gZ2V0U3RvcmVkSXRlbShmdW5jLCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYy5nZXRJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG59XG5mdW5jdGlvbiBzZXRTdG9yZWRJdGVtKGZ1bmMsIGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBmdW5jLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVTdG9yZWRJdGVtKGZ1bmMsIGtleSkge1xuICB0cnkge1xuICAgIGZ1bmMucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoc3RvcmFnZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHNldFN0b3JlZEl0ZW0oc3RvcmFnZSwgYnJvd3NlckNhY2hlQ291bnRLZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gZ2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KHN0b3JhZ2UpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGdldFN0b3JlZEl0ZW0oc3RvcmFnZSwgYnJvd3NlckNhY2hlQ291bnRLZXkpKSB8fCAwO1xufVxuXG5jb25zdCBicm93c2VyU3RvcmFnZUNvbmZpZyA9IHtcbiAgbG9jYWw6IHRydWUsXG4gIHNlc3Npb246IHRydWVcbn07XG5jb25zdCBicm93c2VyU3RvcmFnZUVtcHR5SXRlbXMgPSB7XG4gIGxvY2FsOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICBzZXNzaW9uOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG59O1xubGV0IGJyb3dzZXJTdG9yYWdlU3RhdHVzID0gZmFsc2U7XG5mdW5jdGlvbiBzZXRCcm93c2VyU3RvcmFnZVN0YXR1cyhzdGF0dXMpIHtcbiAgYnJvd3NlclN0b3JhZ2VTdGF0dXMgPSBzdGF0dXM7XG59XG5cbmxldCBfd2luZG93ID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHt9IDogd2luZG93O1xuZnVuY3Rpb24gZ2V0QnJvd3NlclN0b3JhZ2Uoa2V5KSB7XG4gIGNvbnN0IGF0dHIgPSBrZXkgKyBcIlN0b3JhZ2VcIjtcbiAgdHJ5IHtcbiAgICBpZiAoX3dpbmRvdyAmJiBfd2luZG93W2F0dHJdICYmIHR5cGVvZiBfd2luZG93W2F0dHJdLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIF93aW5kb3dbYXR0cl07XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxuICBicm93c2VyU3RvcmFnZUNvbmZpZ1trZXldID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGVCcm93c2VyU3RvcmFnZShrZXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGZ1bmMgPSBnZXRCcm93c2VyU3RvcmFnZShrZXkpO1xuICBpZiAoIWZ1bmMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdmVyc2lvbiA9IGdldFN0b3JlZEl0ZW0oZnVuYywgYnJvd3NlckNhY2hlVmVyc2lvbktleSk7XG4gIGlmICh2ZXJzaW9uICE9PSBicm93c2VyQ2FjaGVWZXJzaW9uKSB7XG4gICAgaWYgKHZlcnNpb24pIHtcbiAgICAgIGNvbnN0IHRvdGFsMiA9IGdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChmdW5jKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWwyOyBpKyspIHtcbiAgICAgICAgcmVtb3ZlU3RvcmVkSXRlbShmdW5jLCBicm93c2VyQ2FjaGVQcmVmaXggKyBpLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRTdG9yZWRJdGVtKGZ1bmMsIGJyb3dzZXJDYWNoZVZlcnNpb25LZXksIGJyb3dzZXJDYWNoZVZlcnNpb24pO1xuICAgIHNldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChmdW5jLCAwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWluVGltZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIGJyb3dzZXJTdG9yYWdlSG91cikgLSBicm93c2VyU3RvcmFnZUNhY2hlRXhwaXJhdGlvbjtcbiAgY29uc3QgcGFyc2VJdGVtID0gKGluZGV4KSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGJyb3dzZXJDYWNoZVByZWZpeCArIGluZGV4LnRvU3RyaW5nKCk7XG4gICAgY29uc3QgaXRlbSA9IGdldFN0b3JlZEl0ZW0oZnVuYywgbmFtZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVtICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGF0YS5jYWNoZWQgPT09IFwibnVtYmVyXCIgJiYgZGF0YS5jYWNoZWQgPiBtaW5UaW1lICYmIHR5cGVvZiBkYXRhLnByb3ZpZGVyID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBkYXRhLmRhdGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGRhdGEuZGF0YS5wcmVmaXggPT09IFwic3RyaW5nXCIgJiYgLy8gVmFsaWQgaXRlbTogcnVuIGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayhkYXRhLCBpbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgfVxuICAgIHJlbW92ZVN0b3JlZEl0ZW0oZnVuYywgbmFtZSk7XG4gIH07XG4gIGxldCB0b3RhbCA9IGdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChmdW5jKTtcbiAgZm9yIChsZXQgaSA9IHRvdGFsIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoIXBhcnNlSXRlbShpKSkge1xuICAgICAgaWYgKGkgPT09IHRvdGFsIC0gMSkge1xuICAgICAgICB0b3RhbC0tO1xuICAgICAgICBzZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYywgdG90YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJvd3NlclN0b3JhZ2VFbXB0eUl0ZW1zW2tleV0uYWRkKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0QnJvd3NlclN0b3JhZ2UoKSB7XG4gIGlmIChicm93c2VyU3RvcmFnZVN0YXR1cykge1xuICAgIHJldHVybjtcbiAgfVxuICBzZXRCcm93c2VyU3RvcmFnZVN0YXR1cyh0cnVlKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYnJvd3NlclN0b3JhZ2VDb25maWcpIHtcbiAgICBpdGVyYXRlQnJvd3NlclN0b3JhZ2Uoa2V5LCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgaWNvblNldCA9IGl0ZW0uZGF0YTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gaXRlbS5wcm92aWRlcjtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGljb25TZXQucHJlZml4O1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoXG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBwcmVmaXhcbiAgICAgICk7XG4gICAgICBpZiAoIWFkZEljb25TZXQoc3RvcmFnZSwgaWNvblNldCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IGljb25TZXQubGFzdE1vZGlmaWVkIHx8IC0xO1xuICAgICAgc3RvcmFnZS5sYXN0TW9kaWZpZWRDYWNoZWQgPSBzdG9yYWdlLmxhc3RNb2RpZmllZENhY2hlZCA/IE1hdGgubWluKHN0b3JhZ2UubGFzdE1vZGlmaWVkQ2FjaGVkLCBsYXN0TW9kaWZpZWQpIDogbGFzdE1vZGlmaWVkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGFzdE1vZGlmaWVkKHN0b3JhZ2UsIGxhc3RNb2RpZmllZCkge1xuICBjb25zdCBsYXN0VmFsdWUgPSBzdG9yYWdlLmxhc3RNb2RpZmllZENhY2hlZDtcbiAgaWYgKFxuICAgIC8vIE1hdGNoZXMgb3IgbmV3ZXJcbiAgICBsYXN0VmFsdWUgJiYgbGFzdFZhbHVlID49IGxhc3RNb2RpZmllZFxuICApIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlID09PSBsYXN0TW9kaWZpZWQ7XG4gIH1cbiAgc3RvcmFnZS5sYXN0TW9kaWZpZWRDYWNoZWQgPSBsYXN0TW9kaWZpZWQ7XG4gIGlmIChsYXN0VmFsdWUpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBicm93c2VyU3RvcmFnZUNvbmZpZykge1xuICAgICAgaXRlcmF0ZUJyb3dzZXJTdG9yYWdlKGtleSwgKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWNvblNldCA9IGl0ZW0uZGF0YTtcbiAgICAgICAgcmV0dXJuIGl0ZW0ucHJvdmlkZXIgIT09IHN0b3JhZ2UucHJvdmlkZXIgfHwgaWNvblNldC5wcmVmaXggIT09IHN0b3JhZ2UucHJlZml4IHx8IGljb25TZXQubGFzdE1vZGlmaWVkID09PSBsYXN0TW9kaWZpZWQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzdG9yZUluQnJvd3NlclN0b3JhZ2Uoc3RvcmFnZSwgZGF0YSkge1xuICBpZiAoIWJyb3dzZXJTdG9yYWdlU3RhdHVzKSB7XG4gICAgaW5pdEJyb3dzZXJTdG9yYWdlKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcmUoa2V5KSB7XG4gICAgbGV0IGZ1bmM7XG4gICAgaWYgKCFicm93c2VyU3RvcmFnZUNvbmZpZ1trZXldIHx8ICEoZnVuYyA9IGdldEJyb3dzZXJTdG9yYWdlKGtleSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNldCA9IGJyb3dzZXJTdG9yYWdlRW1wdHlJdGVtc1trZXldO1xuICAgIGxldCBpbmRleDtcbiAgICBpZiAoc2V0LnNpemUpIHtcbiAgICAgIHNldC5kZWxldGUoaW5kZXggPSBBcnJheS5mcm9tKHNldCkuc2hpZnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gZ2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KGZ1bmMpO1xuICAgICAgaWYgKCFzZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYywgaW5kZXggKyAxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICBjYWNoZWQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIGJyb3dzZXJTdG9yYWdlSG91ciksXG4gICAgICBwcm92aWRlcjogc3RvcmFnZS5wcm92aWRlcixcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBzZXRTdG9yZWRJdGVtKFxuICAgICAgZnVuYyxcbiAgICAgIGJyb3dzZXJDYWNoZVByZWZpeCArIGluZGV4LnRvU3RyaW5nKCksXG4gICAgICBKU09OLnN0cmluZ2lmeShpdGVtKVxuICAgICk7XG4gIH1cbiAgaWYgKGRhdGEubGFzdE1vZGlmaWVkICYmICF1cGRhdGVMYXN0TW9kaWZpZWQoc3RvcmFnZSwgZGF0YS5sYXN0TW9kaWZpZWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghT2JqZWN0LmtleXMoZGF0YS5pY29ucykubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkYXRhLm5vdF9mb3VuZCkge1xuICAgIGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcbiAgICBkZWxldGUgZGF0YS5ub3RfZm91bmQ7XG4gIH1cbiAgaWYgKCFzdG9yZShcImxvY2FsXCIpKSB7XG4gICAgc3RvcmUoXCJzZXNzaW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtcHR5Q2FsbGJhY2soKSB7XG59XG5mdW5jdGlvbiBsb2FkZWROZXdJY29ucyhzdG9yYWdlKSB7XG4gIGlmICghc3RvcmFnZS5pY29uc0xvYWRlckZsYWcpIHtcbiAgICBzdG9yYWdlLmljb25zTG9hZGVyRmxhZyA9IHRydWU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzdG9yYWdlLmljb25zTG9hZGVyRmxhZyA9IGZhbHNlO1xuICAgICAgdXBkYXRlQ2FsbGJhY2tzKHN0b3JhZ2UpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBsb2FkTmV3SWNvbnMoc3RvcmFnZSwgaWNvbnMpIHtcbiAgaWYgKCFzdG9yYWdlLmljb25zVG9Mb2FkKSB7XG4gICAgc3RvcmFnZS5pY29uc1RvTG9hZCA9IGljb25zO1xuICB9IGVsc2Uge1xuICAgIHN0b3JhZ2UuaWNvbnNUb0xvYWQgPSBzdG9yYWdlLmljb25zVG9Mb2FkLmNvbmNhdChpY29ucykuc29ydCgpO1xuICB9XG4gIGlmICghc3RvcmFnZS5pY29uc1F1ZXVlRmxhZykge1xuICAgIHN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RvcmFnZS5pY29uc1F1ZXVlRmxhZyA9IGZhbHNlO1xuICAgICAgY29uc3QgeyBwcm92aWRlciwgcHJlZml4IH0gPSBzdG9yYWdlO1xuICAgICAgY29uc3QgaWNvbnMyID0gc3RvcmFnZS5pY29uc1RvTG9hZDtcbiAgICAgIGRlbGV0ZSBzdG9yYWdlLmljb25zVG9Mb2FkO1xuICAgICAgbGV0IGFwaTtcbiAgICAgIGlmICghaWNvbnMyIHx8ICEoYXBpID0gZ2V0QVBJTW9kdWxlKHByb3ZpZGVyKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyYW1zID0gYXBpLnByZXBhcmUocHJvdmlkZXIsIHByZWZpeCwgaWNvbnMyKTtcbiAgICAgIHBhcmFtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHNlbmRBUElRdWVyeShwcm92aWRlciwgaXRlbSwgKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGl0ZW0uaWNvbnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICBzdG9yYWdlLm1pc3NpbmcuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGFkZEljb25TZXQoXG4gICAgICAgICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICghcGFyc2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nID0gc3RvcmFnZS5wZW5kaW5nSWNvbnM7XG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmcuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JlSW5Ccm93c2VyU3RvcmFnZShzdG9yYWdlLCBkYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvYWRlZE5ld0ljb25zKHN0b3JhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBsb2FkSWNvbnMgPSAoaWNvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGNsZWFuZWRJY29ucyA9IGxpc3RUb0ljb25zKGljb25zLCB0cnVlLCBhbGxvd1NpbXBsZU5hbWVzKCkpO1xuICBjb25zdCBzb3J0ZWRJY29ucyA9IHNvcnRJY29ucyhjbGVhbmVkSWNvbnMpO1xuICBpZiAoIXNvcnRlZEljb25zLnBlbmRpbmcubGVuZ3RoKSB7XG4gICAgbGV0IGNhbGxDYWxsYmFjayA9IHRydWU7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGNhbGxDYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgc29ydGVkSWNvbnMubG9hZGVkLFxuICAgICAgICAgICAgc29ydGVkSWNvbnMubWlzc2luZyxcbiAgICAgICAgICAgIHNvcnRlZEljb25zLnBlbmRpbmcsXG4gICAgICAgICAgICBlbXB0eUNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYWxsQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IG5ld0ljb25zID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgbGV0IGxhc3RQcm92aWRlciwgbGFzdFByZWZpeDtcbiAgc29ydGVkSWNvbnMucGVuZGluZy5mb3JFYWNoKChpY29uKSA9PiB7XG4gICAgY29uc3QgeyBwcm92aWRlciwgcHJlZml4IH0gPSBpY29uO1xuICAgIGlmIChwcmVmaXggPT09IGxhc3RQcmVmaXggJiYgcHJvdmlkZXIgPT09IGxhc3RQcm92aWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXN0UHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICBsYXN0UHJlZml4ID0gcHJlZml4O1xuICAgIHNvdXJjZXMucHVzaChnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpKTtcbiAgICBjb25zdCBwcm92aWRlck5ld0ljb25zID0gbmV3SWNvbnNbcHJvdmlkZXJdIHx8IChuZXdJY29uc1twcm92aWRlcl0gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgaWYgKCFwcm92aWRlck5ld0ljb25zW3ByZWZpeF0pIHtcbiAgICAgIHByb3ZpZGVyTmV3SWNvbnNbcHJlZml4XSA9IFtdO1xuICAgIH1cbiAgfSk7XG4gIHNvcnRlZEljb25zLnBlbmRpbmcuZm9yRWFjaCgoaWNvbikgPT4ge1xuICAgIGNvbnN0IHsgcHJvdmlkZXIsIHByZWZpeCwgbmFtZSB9ID0gaWNvbjtcbiAgICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KTtcbiAgICBjb25zdCBwZW5kaW5nUXVldWUgPSBzdG9yYWdlLnBlbmRpbmdJY29ucyB8fCAoc3RvcmFnZS5wZW5kaW5nSWNvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBpZiAoIXBlbmRpbmdRdWV1ZS5oYXMobmFtZSkpIHtcbiAgICAgIHBlbmRpbmdRdWV1ZS5hZGQobmFtZSk7XG4gICAgICBuZXdJY29uc1twcm92aWRlcl1bcHJlZml4XS5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfSk7XG4gIHNvdXJjZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuICAgIGNvbnN0IHsgcHJvdmlkZXIsIHByZWZpeCB9ID0gc3RvcmFnZTtcbiAgICBpZiAobmV3SWNvbnNbcHJvdmlkZXJdW3ByZWZpeF0ubGVuZ3RoKSB7XG4gICAgICBsb2FkTmV3SWNvbnMoc3RvcmFnZSwgbmV3SWNvbnNbcHJvdmlkZXJdW3ByZWZpeF0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjYWxsYmFjayA/IHN0b3JlQ2FsbGJhY2soY2FsbGJhY2ssIHNvcnRlZEljb25zLCBzb3VyY2VzKSA6IGVtcHR5Q2FsbGJhY2s7XG59O1xuY29uc3QgbG9hZEljb24gPSAoaWNvbikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGljb25PYmogPSB0eXBlb2YgaWNvbiA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZ1RvSWNvbihpY29uLCB0cnVlKSA6IGljb247XG4gICAgaWYgKCFpY29uT2JqKSB7XG4gICAgICByZWplY3QoaWNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvYWRJY29ucyhbaWNvbk9iaiB8fCBpY29uXSwgKGxvYWRlZCkgPT4ge1xuICAgICAgaWYgKGxvYWRlZC5sZW5ndGggJiYgaWNvbk9iaikge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0SWNvbkRhdGEoaWNvbk9iaik7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgZnVsZmlsbCh7XG4gICAgICAgICAgICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICAgICAgICAgICAgLi4uZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVqZWN0KGljb24pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIHRvZ2dsZUJyb3dzZXJDYWNoZShzdG9yYWdlLCB2YWx1ZSkge1xuICBzd2l0Y2ggKHN0b3JhZ2UpIHtcbiAgICBjYXNlIFwibG9jYWxcIjpcbiAgICBjYXNlIFwic2Vzc2lvblwiOlxuICAgICAgYnJvd3NlclN0b3JhZ2VDb25maWdbc3RvcmFnZV0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhbGxcIjpcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGJyb3dzZXJTdG9yYWdlQ29uZmlnKSB7XG4gICAgICAgIGJyb3dzZXJTdG9yYWdlQ29uZmlnW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ3VzdG9taXNhdGlvbnMoZGVmYXVsdHMsIGl0ZW0pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLmRlZmF1bHRzXG4gIH07XG4gIGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcbiAgICBjb25zdCB2YWx1ZSA9IGl0ZW1ba2V5XTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKGtleSBpbiBkZWZhdWx0SWNvblNpemVDdXN0b21pc2F0aW9ucykge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlICYmICh2YWx1ZVR5cGUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWVUeXBlID09PSBcIm51bWJlclwiKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSB0eXBlb2YgcmVzdWx0W2tleV0pIHtcbiAgICAgIHJlc3VsdFtrZXldID0ga2V5ID09PSBcInJvdGF0ZVwiID8gdmFsdWUgJSA0IDogdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHNlcGFyYXRvciA9IC9bXFxzLF0rLztcbmZ1bmN0aW9uIGZsaXBGcm9tU3RyaW5nKGN1c3RvbSwgZmxpcCkge1xuICBmbGlwLnNwbGl0KHNlcGFyYXRvcikuZm9yRWFjaCgoc3RyKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHIudHJpbSgpO1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgIGN1c3RvbS5oRmxpcCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgIGN1c3RvbS52RmxpcCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJvdGF0ZUZyb21TdHJpbmcodmFsdWUsIGRlZmF1bHRWYWx1ZSA9IDApIHtcbiAgY29uc3QgdW5pdHMgPSB2YWx1ZS5yZXBsYWNlKC9eLT9bMC05Ll0qLywgXCJcIik7XG4gIGZ1bmN0aW9uIGNsZWFudXAodmFsdWUyKSB7XG4gICAgd2hpbGUgKHZhbHVlMiA8IDApIHtcbiAgICAgIHZhbHVlMiArPSA0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUyICUgNDtcbiAgfVxuICBpZiAodW5pdHMgPT09IFwiXCIpIHtcbiAgICBjb25zdCBudW0gPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgcmV0dXJuIGlzTmFOKG51bSkgPyAwIDogY2xlYW51cChudW0pO1xuICB9IGVsc2UgaWYgKHVuaXRzICE9PSB2YWx1ZSkge1xuICAgIGxldCBzcGxpdCA9IDA7XG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgc3BsaXQgPSAyNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVnXCI6XG4gICAgICAgIHNwbGl0ID0gOTA7XG4gICAgfVxuICAgIGlmIChzcGxpdCkge1xuICAgICAgbGV0IG51bSA9IHBhcnNlRmxvYXQodmFsdWUuc2xpY2UoMCwgdmFsdWUubGVuZ3RoIC0gdW5pdHMubGVuZ3RoKSk7XG4gICAgICBpZiAoaXNOYU4obnVtKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIG51bSA9IG51bSAvIHNwbGl0O1xuICAgICAgcmV0dXJuIG51bSAlIDEgPT09IDAgPyBjbGVhbnVwKG51bSkgOiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG5mdW5jdGlvbiBpY29uVG9IVE1MKGJvZHksIGF0dHJpYnV0ZXMpIHtcbiAgbGV0IHJlbmRlckF0dHJpYnNIVE1MID0gYm9keS5pbmRleE9mKFwieGxpbms6XCIpID09PSAtMSA/IFwiXCIgOiAnIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiJztcbiAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICByZW5kZXJBdHRyaWJzSFRNTCArPSBcIiBcIiArIGF0dHIgKyAnPVwiJyArIGF0dHJpYnV0ZXNbYXR0cl0gKyAnXCInO1xuICB9XG4gIHJldHVybiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCInICsgcmVuZGVyQXR0cmlic0hUTUwgKyBcIj5cIiArIGJvZHkgKyBcIjwvc3ZnPlwiO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVTVkdmb3JVUkwoc3ZnKSB7XG4gIHJldHVybiBzdmcucmVwbGFjZSgvXCIvZywgXCInXCIpLnJlcGxhY2UoLyUvZywgXCIlMjVcIikucmVwbGFjZSgvIy9nLCBcIiUyM1wiKS5yZXBsYWNlKC88L2csIFwiJTNDXCIpLnJlcGxhY2UoLz4vZywgXCIlM0VcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG59XG5mdW5jdGlvbiBzdmdUb0RhdGEoc3ZnKSB7XG4gIHJldHVybiBcImRhdGE6aW1hZ2Uvc3ZnK3htbCxcIiArIGVuY29kZVNWR2ZvclVSTChzdmcpO1xufVxuZnVuY3Rpb24gc3ZnVG9VUkwoc3ZnKSB7XG4gIHJldHVybiAndXJsKFwiJyArIHN2Z1RvRGF0YShzdmcpICsgJ1wiKSc7XG59XG5cbmxldCBwb2xpY3k7XG5mdW5jdGlvbiBjcmVhdGVQb2xpY3koKSB7XG4gIHRyeSB7XG4gICAgcG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koXCJpY29uaWZ5XCIsIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgY3JlYXRlSFRNTDogKHMpID0+IHNcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcG9saWN5ID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW5VcElubmVySFRNTChodG1sKSB7XG4gIGlmIChwb2xpY3kgPT09IHZvaWQgMCkge1xuICAgIGNyZWF0ZVBvbGljeSgpO1xuICB9XG4gIHJldHVybiBwb2xpY3kgPyBwb2xpY3kuY3JlYXRlSFRNTChodG1sKSA6IGh0bWw7XG59XG5cbmNvbnN0IGRlZmF1bHRFeHRlbmRlZEljb25DdXN0b21pc2F0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0SWNvbkN1c3RvbWlzYXRpb25zLFxuICAgIGlubGluZTogZmFsc2UsXG59O1xuXG4vKipcbiAqIERlZmF1bHQgU1ZHIGF0dHJpYnV0ZXNcbiAqL1xuY29uc3Qgc3ZnRGVmYXVsdHMgPSB7XG4gICAgJ3htbG5zJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAneG1sbnNYbGluayc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICdyb2xlJzogJ2ltZycsXG59O1xuLyoqXG4gKiBTdHlsZSBtb2Rlc1xuICovXG5jb25zdCBjb21tb25Qcm9wcyA9IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbn07XG5jb25zdCBtb25vdG9uZVByb3BzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2N1cnJlbnRDb2xvcicsXG59O1xuY29uc3QgY29sb3JlZFByb3BzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50Jyxcbn07XG4vLyBEeW5hbWljYWxseSBhZGQgY29tbW9uIHByb3BzIHRvIHZhcmlhYmxlcyBhYm92ZVxuY29uc3QgcHJvcHNUb0FkZCA9IHtcbiAgICBJbWFnZTogJ3ZhcigtLXN2ZyknLFxuICAgIFJlcGVhdDogJ25vLXJlcGVhdCcsXG4gICAgU2l6ZTogJzEwMCUgMTAwJScsXG59O1xuY29uc3QgcHJvcHNUb0FkZFRvID0ge1xuICAgIFdlYmtpdE1hc2s6IG1vbm90b25lUHJvcHMsXG4gICAgbWFzazogbW9ub3RvbmVQcm9wcyxcbiAgICBiYWNrZ3JvdW5kOiBjb2xvcmVkUHJvcHMsXG59O1xuZm9yIChjb25zdCBwcmVmaXggaW4gcHJvcHNUb0FkZFRvKSB7XG4gICAgY29uc3QgbGlzdCA9IHByb3BzVG9BZGRUb1twcmVmaXhdO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wc1RvQWRkKSB7XG4gICAgICAgIGxpc3RbcHJlZml4ICsgcHJvcF0gPSBwcm9wc1RvQWRkW3Byb3BdO1xuICAgIH1cbn1cbi8qKlxuICogRGVmYXVsdCB2YWx1ZXMgZm9yIGN1c3RvbWlzYXRpb25zIGZvciBpbmxpbmUgaWNvblxuICovXG5jb25zdCBpbmxpbmVEZWZhdWx0cyA9IHtcbiAgICAuLi5kZWZhdWx0RXh0ZW5kZWRJY29uQ3VzdG9taXNhdGlvbnMsXG4gICAgaW5saW5lOiB0cnVlLFxufTtcbi8qKlxuICogRml4IHNpemU6IGFkZCAncHgnIHRvIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gZml4U2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSArICh2YWx1ZS5tYXRjaCgvXlstMC05Ll0rJC8pID8gJ3B4JyA6ICcnKTtcbn1cbi8qKlxuICogUmVuZGVyIGljb25cbiAqL1xuY29uc3QgcmVuZGVyID0gKFxuLy8gSWNvbiBtdXN0IGJlIHZhbGlkYXRlZCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uXG5pY29uLCBcbi8vIFBhcnRpYWwgcHJvcGVydGllc1xucHJvcHMsIFxuLy8gVHJ1ZSBpZiBpY29uIHNob3VsZCBoYXZlIHZlcnRpY2FsLWFsaWduIGFkZGVkXG5pbmxpbmUsIFxuLy8gT3B0aW9uYWwgcmVmZXJlbmNlIGZvciBTVkcvU1BBTiwgZXh0cmFjdGVkIGJ5IFJlYWN0LmZvcndhcmRSZWYoKVxucmVmKSA9PiB7XG4gICAgLy8gR2V0IGRlZmF1bHQgcHJvcGVydGllc1xuICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IGlubGluZVxuICAgICAgICA/IGlubGluZURlZmF1bHRzXG4gICAgICAgIDogZGVmYXVsdEV4dGVuZGVkSWNvbkN1c3RvbWlzYXRpb25zO1xuICAgIC8vIEdldCBhbGwgY3VzdG9taXNhdGlvbnNcbiAgICBjb25zdCBjdXN0b21pc2F0aW9ucyA9IG1lcmdlQ3VzdG9taXNhdGlvbnMoZGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gICAgLy8gQ2hlY2sgbW9kZVxuICAgIGNvbnN0IG1vZGUgPSBwcm9wcy5tb2RlIHx8ICdzdmcnO1xuICAgIC8vIENyZWF0ZSBzdHlsZVxuICAgIGNvbnN0IHN0eWxlID0ge307XG4gICAgY29uc3QgY3VzdG9tU3R5bGUgPSBwcm9wcy5zdHlsZSB8fCB7fTtcbiAgICAvLyBDcmVhdGUgU1ZHIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgY29tcG9uZW50UHJvcHMgPSB7XG4gICAgICAgIC4uLihtb2RlID09PSAnc3ZnJyA/IHN2Z0RlZmF1bHRzIDoge30pLFxuICAgICAgICByZWYsXG4gICAgfTtcbiAgICAvLyBHZXQgZWxlbWVudCBwcm9wZXJ0aWVzXG4gICAgZm9yIChsZXQga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIHRvIGlnbm9yZVxuICAgICAgICAgICAgY2FzZSAnaWNvbic6XG4gICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgICBjYXNlICdvbkxvYWQnOlxuICAgICAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICBjYXNlICdfcmVmJzpcbiAgICAgICAgICAgIGNhc2UgJ19pbmxpbmUnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQm9vbGVhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjYXNlICdpbmxpbmUnOlxuICAgICAgICAgICAgY2FzZSAnaEZsaXAnOlxuICAgICAgICAgICAgY2FzZSAndkZsaXAnOlxuICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gRmxpcCBhcyBzdHJpbmc6ICdob3Jpem9udGFsLHZlcnRpY2FsJ1xuICAgICAgICAgICAgY2FzZSAnZmxpcCc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxpcEZyb21TdHJpbmcoY3VzdG9taXNhdGlvbnMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDb2xvcjogY29weSB0byBzdHlsZVxuICAgICAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgICAgIHN0eWxlLmNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSb3RhdGlvbiBhcyBzdHJpbmdcbiAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9taXNhdGlvbnNba2V5XSA9IHJvdGF0ZUZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYXJpYS1oaWRkZW5cbiAgICAgICAgICAgIGNhc2UgJ2FyaWFIaWRkZW4nOlxuICAgICAgICAgICAgY2FzZSAnYXJpYS1oaWRkZW4nOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSAmJiB2YWx1ZSAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRQcm9wc1snYXJpYS1oaWRkZW4nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDb3B5IG1pc3NpbmcgcHJvcGVydHkgaWYgaXQgZG9lcyBub3QgZXhpc3QgaW4gY3VzdG9taXNhdGlvbnNcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRQcm9wc1trZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcHNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBpY29uXG4gICAgY29uc3QgaXRlbSA9IGljb25Ub1NWRyhpY29uLCBjdXN0b21pc2F0aW9ucyk7XG4gICAgY29uc3QgcmVuZGVyQXR0cmlicyA9IGl0ZW0uYXR0cmlidXRlcztcbiAgICAvLyBJbmxpbmUgZGlzcGxheVxuICAgIGlmIChjdXN0b21pc2F0aW9ucy5pbmxpbmUpIHtcbiAgICAgICAgc3R5bGUudmVydGljYWxBbGlnbiA9ICctMC4xMjVlbSc7XG4gICAgfVxuICAgIGlmIChtb2RlID09PSAnc3ZnJykge1xuICAgICAgICAvLyBBZGQgc3R5bGVcbiAgICAgICAgY29tcG9uZW50UHJvcHMuc3R5bGUgPSB7XG4gICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIC4uLmN1c3RvbVN0eWxlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBBZGQgaWNvbiBzdHVmZlxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbXBvbmVudFByb3BzLCByZW5kZXJBdHRyaWJzKTtcbiAgICAgICAgLy8gQ291bnRlciBmb3IgaWRzIGJhc2VkIG9uIFwiaWRcIiBwcm9wZXJ0eSB0byByZW5kZXIgaWNvbnMgY29uc2lzdGVudGx5IG9uIHNlcnZlciBhbmQgY2xpZW50XG4gICAgICAgIGxldCBsb2NhbENvdW50ZXIgPSAwO1xuICAgICAgICBsZXQgaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgJy0nIHRvICdfJyB0byBhdm9pZCBlcnJvcnMgaW4gYW5pbWF0aW9uc1xuICAgICAgICAgICAgaWQgPSBpZC5yZXBsYWNlKC8tL2csICdfJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGljb24gc3R1ZmZcbiAgICAgICAgY29tcG9uZW50UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7XG4gICAgICAgICAgICBfX2h0bWw6IGNsZWFuVXBJbm5lckhUTUwocmVwbGFjZUlEcyhpdGVtLmJvZHksIGlkID8gKCkgPT4gaWQgKyAnSUQnICsgbG9jYWxDb3VudGVyKysgOiAnaWNvbmlmeVJlYWN0JykpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnc3ZnJywgY29tcG9uZW50UHJvcHMpO1xuICAgIH1cbiAgICAvLyBSZW5kZXIgPHNwYW4+IHdpdGggc3R5bGVcbiAgICBjb25zdCB7IGJvZHksIHdpZHRoLCBoZWlnaHQgfSA9IGljb247XG4gICAgY29uc3QgdXNlTWFzayA9IG1vZGUgPT09ICdtYXNrJyB8fFxuICAgICAgICAobW9kZSA9PT0gJ2JnJyA/IGZhbHNlIDogYm9keS5pbmRleE9mKCdjdXJyZW50Q29sb3InKSAhPT0gLTEpO1xuICAgIC8vIEdlbmVyYXRlIFNWR1xuICAgIGNvbnN0IGh0bWwgPSBpY29uVG9IVE1MKGJvZHksIHtcbiAgICAgICAgLi4ucmVuZGVyQXR0cmlicyxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgJycsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJycsXG4gICAgfSk7XG4gICAgLy8gR2VuZXJhdGUgc3R5bGVcbiAgICBjb21wb25lbnRQcm9wcy5zdHlsZSA9IHtcbiAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICctLXN2Zyc6IHN2Z1RvVVJMKGh0bWwpLFxuICAgICAgICAnd2lkdGgnOiBmaXhTaXplKHJlbmRlckF0dHJpYnMud2lkdGgpLFxuICAgICAgICAnaGVpZ2h0JzogZml4U2l6ZShyZW5kZXJBdHRyaWJzLmhlaWdodCksXG4gICAgICAgIC4uLmNvbW1vblByb3BzLFxuICAgICAgICAuLi4odXNlTWFzayA/IG1vbm90b25lUHJvcHMgOiBjb2xvcmVkUHJvcHMpLFxuICAgICAgICAuLi5jdXN0b21TdHlsZSxcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdzcGFuJywgY29tcG9uZW50UHJvcHMpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgY2FjaGVcbiAqL1xuZnVuY3Rpb24gZW5hYmxlQ2FjaGUoc3RvcmFnZSkge1xuICAgIHRvZ2dsZUJyb3dzZXJDYWNoZShzdG9yYWdlLCB0cnVlKTtcbn1cbi8qKlxuICogRGlzYWJsZSBjYWNoZVxuICovXG5mdW5jdGlvbiBkaXNhYmxlQ2FjaGUoc3RvcmFnZSkge1xuICAgIHRvZ2dsZUJyb3dzZXJDYWNoZShzdG9yYWdlLCBmYWxzZSk7XG59XG4vKipcbiAqIEluaXRpYWxpc2Ugc3R1ZmZcbiAqL1xuLy8gRW5hYmxlIHNob3J0IG5hbWVzXG5hbGxvd1NpbXBsZU5hbWVzKHRydWUpO1xuLy8gU2V0IEFQSSBtb2R1bGVcbnNldEFQSU1vZHVsZSgnJywgZmV0Y2hBUElNb2R1bGUpO1xuLyoqXG4gKiBCcm93c2VyIHN0dWZmXG4gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gU2V0IGNhY2hlIGFuZCBsb2FkIGV4aXN0aW5nIGNhY2hlXG4gICAgaW5pdEJyb3dzZXJTdG9yYWdlKCk7XG4gICAgY29uc3QgX3dpbmRvdyA9IHdpbmRvdztcbiAgICAvLyBMb2FkIGljb25zIGZyb20gZ2xvYmFsIFwiSWNvbmlmeVByZWxvYWRcIlxuICAgIGlmIChfd2luZG93Lkljb25pZnlQcmVsb2FkICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgcHJlbG9hZCA9IF93aW5kb3cuSWNvbmlmeVByZWxvYWQ7XG4gICAgICAgIGNvbnN0IGVyciA9ICdJbnZhbGlkIEljb25pZnlQcmVsb2FkIHN5bnRheC4nO1xuICAgICAgICBpZiAodHlwZW9mIHByZWxvYWQgPT09ICdvYmplY3QnICYmIHByZWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIChwcmVsb2FkIGluc3RhbmNlb2YgQXJyYXkgPyBwcmVsb2FkIDogW3ByZWxvYWRdKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdGVtIGlzIGFuIG9iamVjdCBhbmQgbm90IG51bGwvYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtIGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciAnaWNvbnMnIGFuZCAncHJlZml4J1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0uaWNvbnMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbS5wcmVmaXggIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgaWNvbiBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICFhZGRDb2xsZWN0aW9uKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNldCBBUEkgZnJvbSBnbG9iYWwgXCJJY29uaWZ5UHJvdmlkZXJzXCJcbiAgICBpZiAoX3dpbmRvdy5JY29uaWZ5UHJvdmlkZXJzICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJzID0gX3dpbmRvdy5JY29uaWZ5UHJvdmlkZXJzO1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVycyA9PT0gJ29iamVjdCcgJiYgcHJvdmlkZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gJ0ljb25pZnlQcm92aWRlcnNbJyArIGtleSArICddIGlzIGludmFsaWQuJztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3ZpZGVyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZXNvdXJjZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGRBUElQcm92aWRlcihrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBJY29uQ29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAvLyBSZW5kZXIgcGxhY2Vob2xkZXIgYmVmb3JlIGNvbXBvbmVudCBpcyBtb3VudGVkXG4gICAgICAgICAgICBpY29uOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBYm9ydCBsb2FkaW5nIGljb25cbiAgICAgKi9cbiAgICBfYWJvcnRMb2FkaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5fbG9hZGluZykge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGluZy5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5fbG9hZGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN0YXRlXG4gICAgICovXG4gICAgX3NldERhdGEoaWNvbikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pY29uICE9PSBpY29uKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpY29uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgaWNvbiBzaG91bGQgYmUgbG9hZGVkXG4gICAgICovXG4gICAgX2NoZWNrSWNvbihjaGFuZ2VkKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMucHJvcHMuaWNvbjtcbiAgICAgICAgLy8gSWNvbiBpcyBhbiBvYmplY3RcbiAgICAgICAgaWYgKHR5cGVvZiBpY29uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgaWNvbiAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGljb24uYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5faWNvbiA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCB8fCBzdGF0ZS5pY29uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGRhdGEgaWYgaXQgd2FzIGNoYW5nZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaWNvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnZhbGlkIGljb24/XG4gICAgICAgIGxldCBpY29uTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpY29uICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKGljb25OYW1lID0gc3RyaW5nVG9JY29uKGljb24sIGZhbHNlLCB0cnVlKSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0TG9hZGluZygpO1xuICAgICAgICAgICAgdGhpcy5fc2V0RGF0YShudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2FkIGljb25cbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEljb25EYXRhKGljb25OYW1lKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAvLyBJY29uIGRhdGEgaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2FkaW5nIHx8IHRoaXMuX2xvYWRpbmcubmFtZSAhPT0gaWNvbikge1xuICAgICAgICAgICAgICAgIC8vIE5ldyBpY29uIHRvIGxvYWRcbiAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydExvYWRpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pY29uID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RGF0YShudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJY29uIHdhcyBub3QgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpY29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGxvYWRJY29ucyhbaWNvbk5hbWVdLCB0aGlzLl9jaGVja0ljb24uYmluZCh0aGlzLCBmYWxzZSkpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJY29uIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgICAgIGlmICh0aGlzLl9pY29uICE9PSBpY29uIHx8IHN0YXRlLmljb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE5ldyBpY29uIG9yIGljb24gaGFzIGJlZW4gbG9hZGVkXG4gICAgICAgICAgICB0aGlzLl9hYm9ydExvYWRpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX2ljb24gPSBpY29uO1xuICAgICAgICAgICAgLy8gQWRkIGNsYXNzZXNcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbJ2ljb25pZnknXTtcbiAgICAgICAgICAgIGlmIChpY29uTmFtZS5wcmVmaXggIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdpY29uaWZ5LS0nICsgaWNvbk5hbWUucHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpY29uTmFtZS5wcm92aWRlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ljb25pZnktLScgKyBpY29uTmFtZS5wcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgZGF0YVxuICAgICAgICAgICAgdGhpcy5fc2V0RGF0YSh7XG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBjbGFzc2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZChpY29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgbW91bnRlZFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLl9jaGVja0ljb24oZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgdXBkYXRlZFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZShvbGRQcm9wcykge1xuICAgICAgICBpZiAob2xkUHJvcHMuaWNvbiAhPT0gdGhpcy5wcm9wcy5pY29uKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0ljb24odHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJvcnQgbG9hZGluZ1xuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLl9hYm9ydExvYWRpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGljb24gPSB0aGlzLnN0YXRlLmljb247XG4gICAgICAgIGlmIChpY29uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZW5kZXIgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlblxuICAgICAgICAgICAgICAgID8gcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGNsYXNzZXNcbiAgICAgICAgbGV0IG5ld1Byb3BzID0gcHJvcHM7XG4gICAgICAgIGlmIChpY29uLmNsYXNzZXMpIHtcbiAgICAgICAgICAgIG5ld1Byb3BzID0ge1xuICAgICAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogKHR5cGVvZiBwcm9wcy5jbGFzc05hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gcHJvcHMuY2xhc3NOYW1lICsgJyAnXG4gICAgICAgICAgICAgICAgICAgIDogJycpICsgaWNvbi5jbGFzc2VzLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZGVyIGljb25cbiAgICAgICAgcmV0dXJuIHJlbmRlcih7XG4gICAgICAgICAgICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICAgICAgICAgICAgLi4uaWNvbi5kYXRhLFxuICAgICAgICB9LCBuZXdQcm9wcywgcHJvcHMuX2lubGluZSwgcHJvcHMuX3JlZik7XG4gICAgfVxufVxuLyoqXG4gKiBCbG9jayBpY29uXG4gKlxuICogQHBhcmFtIHByb3BzIC0gQ29tcG9uZW50IHByb3BlcnRpZXNcbiAqL1xuY29uc3QgSWNvbiA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gSWNvbihwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBfcmVmOiByZWYsXG4gICAgICAgIF9pbmxpbmU6IGZhbHNlLFxuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkNvbXBvbmVudCwgbmV3UHJvcHMpO1xufSk7XG4vKipcbiAqIElubGluZSBpY29uIChoYXMgbmVnYXRpdmUgdmVydGljYWxBbGlnbiB0aGF0IG1ha2VzIGl0IGJlaGF2ZSBsaWtlIGljb24gZm9udClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBDb21wb25lbnQgcHJvcGVydGllc1xuICovXG5jb25zdCBJbmxpbmVJY29uID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBJbmxpbmVJY29uKHByb3BzLCByZWYpIHtcbiAgICBjb25zdCBuZXdQcm9wcyA9IHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIF9yZWY6IHJlZixcbiAgICAgICAgX2lubGluZTogdHJ1ZSxcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25Db21wb25lbnQsIG5ld1Byb3BzKTtcbn0pO1xuLyoqXG4gKiBJbnRlcm5hbCBBUElcbiAqL1xuY29uc3QgX2FwaSA9IHtcbiAgICBnZXRBUElDb25maWcsXG4gICAgc2V0QVBJTW9kdWxlLFxuICAgIHNlbmRBUElRdWVyeSxcbiAgICBzZXRGZXRjaCxcbiAgICBnZXRGZXRjaCxcbiAgICBsaXN0QVBJUHJvdmlkZXJzLFxufTtcblxuZXhwb3J0IHsgSWNvbiwgSW5saW5lSWNvbiwgX2FwaSwgYWRkQVBJUHJvdmlkZXIsIGFkZENvbGxlY3Rpb24sIGFkZEljb24sIGljb25Ub1NWRyBhcyBidWlsZEljb24sIGNhbGN1bGF0ZVNpemUsIGRpc2FibGVDYWNoZSwgZW5hYmxlQ2FjaGUsIGdldEljb24sIGljb25FeGlzdHMsIGxpc3RJY29ucywgbG9hZEljb24sIGxvYWRJY29ucywgcmVwbGFjZUlEcyB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwibWF0Y2hJY29uTmFtZSIsInN0cmluZ1RvSWNvbiIsInZhbHVlIiwidmFsaWRhdGUiLCJhbGxvd1NpbXBsZU5hbWUiLCJwcm92aWRlciIsImNvbG9uU2VwYXJhdGVkIiwic3BsaXQiLCJzbGljZSIsImxlbmd0aCIsInNoaWZ0IiwibmFtZTIiLCJwb3AiLCJwcmVmaXgiLCJyZXN1bHQiLCJuYW1lIiwidmFsaWRhdGVJY29uTmFtZSIsImRhc2hTZXBhcmF0ZWQiLCJqb2luIiwiaWNvbiIsIm1hdGNoIiwiZGVmYXVsdEljb25EaW1lbnNpb25zIiwiT2JqZWN0IiwiZnJlZXplIiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiZGVmYXVsdEljb25UcmFuc2Zvcm1hdGlvbnMiLCJyb3RhdGUiLCJ2RmxpcCIsImhGbGlwIiwiZGVmYXVsdEljb25Qcm9wcyIsImRlZmF1bHRFeHRlbmRlZEljb25Qcm9wcyIsImJvZHkiLCJoaWRkZW4iLCJtZXJnZUljb25UcmFuc2Zvcm1hdGlvbnMiLCJvYmoxIiwib2JqMiIsIm1lcmdlSWNvbkRhdGEiLCJwYXJlbnQiLCJjaGlsZCIsImtleSIsImdldEljb25zVHJlZSIsImRhdGEiLCJuYW1lcyIsImljb25zIiwiYWxpYXNlcyIsImNyZWF0ZSIsInJlc29sdmVkIiwicmVzb2x2ZSIsImNvbmNhdCIsImtleXMiLCJmb3JFYWNoIiwiaW50ZXJuYWxHZXRJY29uRGF0YSIsInRyZWUiLCJjdXJyZW50UHJvcHMiLCJwYXJzZSIsInBhcnNlSWNvblNldCIsImNhbGxiYWNrIiwibm90X2ZvdW5kIiwiQXJyYXkiLCJwdXNoIiwiaXRlbSIsIm9wdGlvbmFsUHJvcGVydHlEZWZhdWx0cyIsImNoZWNrT3B0aW9uYWxQcm9wcyIsImRlZmF1bHRzIiwicHJvcCIsInF1aWNrbHlWYWxpZGF0ZUljb25TZXQiLCJvYmoiLCJkYXRhU3RvcmFnZSIsIm5ld1N0b3JhZ2UiLCJtaXNzaW5nIiwiU2V0IiwiZ2V0U3RvcmFnZSIsInByb3ZpZGVyU3RvcmFnZSIsImFkZEljb25TZXQiLCJzdG9yYWdlIiwiYWRkIiwiYWRkSWNvblRvU3RvcmFnZSIsImVyciIsImxpc3RJY29ucyIsImFsbEljb25zIiwicHJvdmlkZXJzIiwicHJvdmlkZXIyIiwicHJlZml4ZXMiLCJwcmVmaXgyIiwibWFwIiwic2ltcGxlTmFtZXMiLCJhbGxvd1NpbXBsZU5hbWVzIiwiYWxsb3ciLCJnZXRJY29uRGF0YSIsImljb25OYW1lIiwiaGFzIiwiYWRkSWNvbiIsImFkZENvbGxlY3Rpb24iLCJhZGRlZCIsImljb25FeGlzdHMiLCJnZXRJY29uIiwiZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMiLCJkZWZhdWx0SWNvbkN1c3RvbWlzYXRpb25zIiwidW5pdHNTcGxpdCIsInVuaXRzVGVzdCIsImNhbGN1bGF0ZVNpemUiLCJzaXplIiwicmF0aW8iLCJwcmVjaXNpb24iLCJNYXRoIiwiY2VpbCIsIm9sZFBhcnRzIiwibmV3UGFydHMiLCJjb2RlIiwiaXNOdW1iZXIiLCJ0ZXN0IiwibnVtIiwicGFyc2VGbG9hdCIsImlzTmFOIiwiaXNVbnNldEtleXdvcmQiLCJpY29uVG9TVkciLCJjdXN0b21pc2F0aW9ucyIsImZ1bGxJY29uIiwiZnVsbEN1c3RvbWlzYXRpb25zIiwiYm94IiwicHJvcHMiLCJ0cmFuc2Zvcm1hdGlvbnMiLCJyb3RhdGlvbiIsInRvU3RyaW5nIiwidGVtcFZhbHVlIiwiZmxvb3IiLCJ1bnNoaWZ0IiwiY3VzdG9taXNhdGlvbnNXaWR0aCIsImN1c3RvbWlzYXRpb25zSGVpZ2h0IiwiYm94V2lkdGgiLCJib3hIZWlnaHQiLCJhdHRyaWJ1dGVzIiwic2V0QXR0ciIsInZpZXdCb3giLCJyZWdleCIsInJhbmRvbVByZWZpeCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJjb3VudGVyIiwicmVwbGFjZUlEcyIsImlkcyIsImV4ZWMiLCJzdWZmaXgiLCJpZCIsIm5ld0lEIiwiZXNjYXBlZElEIiwicmVwbGFjZSIsIlJlZ0V4cCIsInNldEFQSU1vZHVsZSIsImdldEFQSU1vZHVsZSIsImNyZWF0ZUFQSUNvbmZpZyIsInNvdXJjZSIsInJlc291cmNlcyIsInBhdGgiLCJtYXhVUkwiLCJ0aW1lb3V0IiwiaW5kZXgiLCJkYXRhQWZ0ZXJUaW1lb3V0IiwiY29uZmlnU3RvcmFnZSIsImZhbGxCYWNrQVBJU291cmNlcyIsImZhbGxCYWNrQVBJIiwiYWRkQVBJUHJvdmlkZXIiLCJjdXN0b21Db25maWciLCJjb25maWciLCJnZXRBUElDb25maWciLCJsaXN0QVBJUHJvdmlkZXJzIiwiZGV0ZWN0RmV0Y2giLCJmZXRjaCIsImZldGNoTW9kdWxlIiwic2V0RmV0Y2giLCJmZXRjaDIiLCJnZXRGZXRjaCIsImNhbGN1bGF0ZU1heExlbmd0aCIsIm1heEhvc3RMZW5ndGgiLCJob3N0IiwibWF4IiwidXJsIiwic2hvdWxkQWJvcnQiLCJzdGF0dXMiLCJwcmVwYXJlIiwicmVzdWx0cyIsIm1heExlbmd0aCIsInR5cGUiLCJnZXRQYXRoIiwic2VuZCIsInBhcmFtcyIsImljb25zTGlzdCIsInVybFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInVyaSIsImRlZmF1bHRFcnJvciIsInRoZW4iLCJyZXNwb25zZSIsInNldFRpbWVvdXQiLCJqc29uIiwiY2F0Y2giLCJmZXRjaEFQSU1vZHVsZSIsInNvcnRJY29ucyIsImxvYWRlZCIsInBlbmRpbmciLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwibGFzdEljb24iLCJsb2NhbFN0b3JhZ2UiLCJsaXN0IiwicmVtb3ZlQ2FsbGJhY2siLCJzdG9yYWdlcyIsIml0ZW1zIiwibG9hZGVyQ2FsbGJhY2tzIiwiZmlsdGVyIiwicm93IiwidXBkYXRlQ2FsbGJhY2tzIiwicGVuZGluZ0NhbGxiYWNrc0ZsYWciLCJoYXNQZW5kaW5nIiwib2xkTGVuZ3RoIiwiYWJvcnQiLCJpZENvdW50ZXIiLCJzdG9yZUNhbGxiYWNrIiwicGVuZGluZ1NvdXJjZXMiLCJiaW5kIiwibGlzdFRvSWNvbnMiLCJkZWZhdWx0Q29uZmlnIiwic2VuZFF1ZXJ5IiwicGF5bG9hZCIsInF1ZXJ5IiwiZG9uZSIsInJlc291cmNlc0NvdW50Iiwic3RhcnRJbmRleCIsIm5leHRJbmRleCIsInN0YXJ0VGltZSIsInF1ZXJpZXNTZW50IiwibGFzdEVycm9yIiwidGltZXIiLCJxdWV1ZSIsImRvbmVDYWxsYmFja3MiLCJyZXNldFRpbWVyIiwiY2xlYXJUaW1lb3V0Iiwic3Vic2NyaWJlIiwib3ZlcndyaXRlIiwiZ2V0UXVlcnlTdGF0dXMiLCJxdWVyaWVzUGVuZGluZyIsImZhaWxRdWVyeSIsImNsZWFyUXVldWUiLCJtb2R1bGVSZXNwb25zZSIsImlzRXJyb3IiLCJxdWV1ZWQiLCJleGVjTmV4dCIsImluZGV4T2YiLCJyZXNvdXJjZSIsInN0YXR1czIiLCJpbml0UmVkdW5kYW5jeSIsImNmZyIsInF1ZXJpZXMiLCJjbGVhbnVwIiwicXVlcnlDYWxsYmFjayIsImRvbmVDYWxsYmFjayIsInF1ZXJ5MiIsImVycm9yIiwiZmluZCIsImluc3RhbmNlIiwic2V0SW5kZXgiLCJnZXRJbmRleCIsImVtcHR5Q2FsbGJhY2skMSIsInJlZHVuZGFuY3lDYWNoZSIsImdldFJlZHVuZGFuY3lDYWNoZSIsInJlZHVuZGFuY3kiLCJjYWNoZWRSZXVuZGFuY3kiLCJzZW5kQVBJUXVlcnkiLCJ0YXJnZXQiLCJhcGkiLCJjYWNoZWQiLCJtb2R1bGVLZXkiLCJicm93c2VyQ2FjaGVWZXJzaW9uIiwiYnJvd3NlckNhY2hlUHJlZml4IiwiYnJvd3NlckNhY2hlQ291bnRLZXkiLCJicm93c2VyQ2FjaGVWZXJzaW9uS2V5IiwiYnJvd3NlclN0b3JhZ2VIb3VyIiwiYnJvd3NlclN0b3JhZ2VDYWNoZUV4cGlyYXRpb24iLCJnZXRTdG9yZWRJdGVtIiwiZnVuYyIsImdldEl0ZW0iLCJzZXRTdG9yZWRJdGVtIiwic2V0SXRlbSIsInJlbW92ZVN0b3JlZEl0ZW0iLCJyZW1vdmVJdGVtIiwic2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50IiwiZ2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50IiwicGFyc2VJbnQiLCJicm93c2VyU3RvcmFnZUNvbmZpZyIsImxvY2FsIiwic2Vzc2lvbiIsImJyb3dzZXJTdG9yYWdlRW1wdHlJdGVtcyIsImJyb3dzZXJTdG9yYWdlU3RhdHVzIiwic2V0QnJvd3NlclN0b3JhZ2VTdGF0dXMiLCJfd2luZG93Iiwid2luZG93IiwiZ2V0QnJvd3NlclN0b3JhZ2UiLCJhdHRyIiwiaXRlcmF0ZUJyb3dzZXJTdG9yYWdlIiwidmVyc2lvbiIsInRvdGFsMiIsImkiLCJtaW5UaW1lIiwicGFyc2VJdGVtIiwiSlNPTiIsInRvdGFsIiwiaW5pdEJyb3dzZXJTdG9yYWdlIiwiaWNvblNldCIsImxhc3RNb2RpZmllZCIsImxhc3RNb2RpZmllZENhY2hlZCIsIm1pbiIsInVwZGF0ZUxhc3RNb2RpZmllZCIsImxhc3RWYWx1ZSIsInN0b3JlSW5Ccm93c2VyU3RvcmFnZSIsInN0b3JlIiwic2V0IiwiZGVsZXRlIiwiZnJvbSIsInN0cmluZ2lmeSIsImFzc2lnbiIsImVtcHR5Q2FsbGJhY2siLCJsb2FkZWROZXdJY29ucyIsImljb25zTG9hZGVyRmxhZyIsImxvYWROZXdJY29ucyIsImljb25zVG9Mb2FkIiwiaWNvbnNRdWV1ZUZsYWciLCJpY29uczIiLCJwYXJzZWQiLCJwZW5kaW5nSWNvbnMiLCJjb25zb2xlIiwibG9hZEljb25zIiwiY2xlYW5lZEljb25zIiwic29ydGVkSWNvbnMiLCJjYWxsQ2FsbGJhY2siLCJuZXdJY29ucyIsInNvdXJjZXMiLCJsYXN0UHJvdmlkZXIiLCJsYXN0UHJlZml4IiwicHJvdmlkZXJOZXdJY29ucyIsInBlbmRpbmdRdWV1ZSIsImxvYWRJY29uIiwiUHJvbWlzZSIsImZ1bGZpbGwiLCJyZWplY3QiLCJpY29uT2JqIiwidG9nZ2xlQnJvd3NlckNhY2hlIiwibWVyZ2VDdXN0b21pc2F0aW9ucyIsInZhbHVlVHlwZSIsInNlcGFyYXRvciIsImZsaXBGcm9tU3RyaW5nIiwiY3VzdG9tIiwiZmxpcCIsInN0ciIsInRyaW0iLCJyb3RhdGVGcm9tU3RyaW5nIiwiZGVmYXVsdFZhbHVlIiwidW5pdHMiLCJ2YWx1ZTIiLCJpY29uVG9IVE1MIiwicmVuZGVyQXR0cmlic0hUTUwiLCJlbmNvZGVTVkdmb3JVUkwiLCJzdmciLCJzdmdUb0RhdGEiLCJzdmdUb1VSTCIsInBvbGljeSIsImNyZWF0ZVBvbGljeSIsInRydXN0ZWRUeXBlcyIsImNyZWF0ZUhUTUwiLCJzIiwiY2xlYW5VcElubmVySFRNTCIsImh0bWwiLCJkZWZhdWx0RXh0ZW5kZWRJY29uQ3VzdG9taXNhdGlvbnMiLCJpbmxpbmUiLCJzdmdEZWZhdWx0cyIsImNvbW1vblByb3BzIiwiZGlzcGxheSIsIm1vbm90b25lUHJvcHMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvcmVkUHJvcHMiLCJwcm9wc1RvQWRkIiwiSW1hZ2UiLCJSZXBlYXQiLCJTaXplIiwicHJvcHNUb0FkZFRvIiwiV2Via2l0TWFzayIsIm1hc2siLCJiYWNrZ3JvdW5kIiwiaW5saW5lRGVmYXVsdHMiLCJmaXhTaXplIiwicmVuZGVyIiwicmVmIiwiZGVmYXVsdFByb3BzIiwibW9kZSIsInN0eWxlIiwiY3VzdG9tU3R5bGUiLCJjb21wb25lbnRQcm9wcyIsImNvbG9yIiwicmVuZGVyQXR0cmlicyIsInZlcnRpY2FsQWxpZ24iLCJsb2NhbENvdW50ZXIiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VNYXNrIiwiZW5hYmxlQ2FjaGUiLCJkaXNhYmxlQ2FjaGUiLCJkb2N1bWVudCIsIkljb25pZnlQcmVsb2FkIiwicHJlbG9hZCIsImUiLCJJY29uaWZ5UHJvdmlkZXJzIiwiSWNvbkNvbXBvbmVudCIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwic3RhdGUiLCJfYWJvcnRMb2FkaW5nIiwiX2xvYWRpbmciLCJfc2V0RGF0YSIsInNldFN0YXRlIiwiX2NoZWNrSWNvbiIsImNoYW5nZWQiLCJfaWNvbiIsImNsYXNzZXMiLCJvbkxvYWQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm9sZFByb3BzIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJjaGlsZHJlbiIsIm5ld1Byb3BzIiwiY2xhc3NOYW1lIiwiX2lubGluZSIsIl9yZWYiLCJJY29uIiwiZm9yd2FyZFJlZiIsIklubGluZUljb24iLCJfYXBpIiwiYnVpbGRJY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@iconify/react/dist/iconify.mjs\n");

/***/ })

};
;