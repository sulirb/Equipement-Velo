"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/draftjs-to-html";
exports.ids = ["vendor-chunks/draftjs-to-html"];
exports.modules = {

/***/ "(ssr)/./node_modules/draftjs-to-html/lib/draftjs-to-html.js":
/*!*************************************************************!*\
  !*** ./node_modules/draftjs-to-html/lib/draftjs-to-html.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\n(function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(void 0, function() {\n    \"use strict\";\n    /**\n  * Utility function to execute callback for eack key->value pair.\n  */ function forEach(obj, callback) {\n        if (obj) {\n            for(var key in obj){\n                // eslint-disable-line no-restricted-syntax\n                if (({}).hasOwnProperty.call(obj, key)) {\n                    callback(key, obj[key]);\n                }\n            }\n        }\n    }\n    /**\n  * The function returns true if the string passed to it has no content.\n  */ function isEmptyString(str) {\n        if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n            return true;\n        }\n        return false;\n    }\n    /**\n  * Mapping block-type to corresponding html tag.\n  */ var blockTypesMapping = {\n        unstyled: \"p\",\n        \"header-one\": \"h1\",\n        \"header-two\": \"h2\",\n        \"header-three\": \"h3\",\n        \"header-four\": \"h4\",\n        \"header-five\": \"h5\",\n        \"header-six\": \"h6\",\n        \"unordered-list-item\": \"ul\",\n        \"ordered-list-item\": \"ol\",\n        blockquote: \"blockquote\",\n        code: \"pre\"\n    };\n    /**\n  * Function will return HTML tag for a block.\n  */ function getBlockTag(type) {\n        return type && blockTypesMapping[type];\n    }\n    /**\n  * Function will return style string for a block.\n  */ function getBlockStyle(data) {\n        var styles = \"\";\n        forEach(data, function(key, value) {\n            if (value) {\n                styles += \"\".concat(key, \":\").concat(value, \";\");\n            }\n        });\n        return styles;\n    }\n    /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */ function getHashtagRanges(blockText, hashtagConfig) {\n        var sections = [];\n        if (hashtagConfig) {\n            var counter = 0;\n            var startIndex = 0;\n            var text = blockText;\n            var trigger = hashtagConfig.trigger || \"#\";\n            var separator = hashtagConfig.separator || \" \";\n            for(; text.length > 0 && startIndex >= 0;){\n                if (text[0] === trigger) {\n                    startIndex = 0;\n                    counter = 0;\n                    text = text.substr(trigger.length);\n                } else {\n                    startIndex = text.indexOf(separator + trigger);\n                    if (startIndex >= 0) {\n                        text = text.substr(startIndex + (separator + trigger).length);\n                        counter += startIndex + separator.length;\n                    }\n                }\n                if (startIndex >= 0) {\n                    var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n                    var hashtag = text.substr(0, endIndex);\n                    if (hashtag && hashtag.length > 0) {\n                        sections.push({\n                            offset: counter,\n                            length: hashtag.length + trigger.length,\n                            type: \"HASHTAG\"\n                        });\n                    }\n                    counter += trigger.length;\n                }\n            }\n        }\n        return sections;\n    }\n    /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */ function getSections(block, hashtagConfig) {\n        var sections = [];\n        var lastOffset = 0;\n        var sectionRanges = block.entityRanges.map(function(range) {\n            var offset = range.offset, length = range.length, key = range.key;\n            return {\n                offset: offset,\n                length: length,\n                key: key,\n                type: \"ENTITY\"\n            };\n        });\n        sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n        sectionRanges = sectionRanges.sort(function(s1, s2) {\n            return s1.offset - s2.offset;\n        });\n        sectionRanges.forEach(function(r) {\n            if (r.offset > lastOffset) {\n                sections.push({\n                    start: lastOffset,\n                    end: r.offset\n                });\n            }\n            sections.push({\n                start: r.offset,\n                end: r.offset + r.length,\n                entityKey: r.key,\n                type: r.type\n            });\n            lastOffset = r.offset + r.length;\n        });\n        if (lastOffset < block.text.length) {\n            sections.push({\n                start: lastOffset,\n                end: block.text.length\n            });\n        }\n        return sections;\n    }\n    /**\n  * Function to check if the block is an atomic entity block.\n  */ function isAtomicEntityBlock(block) {\n        if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === \"atomic\")) {\n            return true;\n        }\n        return false;\n    }\n    /**\n  * The function will return array of inline styles applicable to the block.\n  */ function getStyleArrayForBlock(block) {\n        var text = block.text, inlineStyleRanges = block.inlineStyleRanges;\n        var inlineStyles = {\n            BOLD: new Array(text.length),\n            ITALIC: new Array(text.length),\n            UNDERLINE: new Array(text.length),\n            STRIKETHROUGH: new Array(text.length),\n            CODE: new Array(text.length),\n            SUPERSCRIPT: new Array(text.length),\n            SUBSCRIPT: new Array(text.length),\n            COLOR: new Array(text.length),\n            BGCOLOR: new Array(text.length),\n            FONTSIZE: new Array(text.length),\n            FONTFAMILY: new Array(text.length),\n            length: text.length\n        };\n        if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n            inlineStyleRanges.forEach(function(range) {\n                var offset = range.offset;\n                var length = offset + range.length;\n                for(var i = offset; i < length; i += 1){\n                    if (range.style.indexOf(\"color-\") === 0) {\n                        inlineStyles.COLOR[i] = range.style.substring(6);\n                    } else if (range.style.indexOf(\"bgcolor-\") === 0) {\n                        inlineStyles.BGCOLOR[i] = range.style.substring(8);\n                    } else if (range.style.indexOf(\"fontsize-\") === 0) {\n                        inlineStyles.FONTSIZE[i] = range.style.substring(9);\n                    } else if (range.style.indexOf(\"fontfamily-\") === 0) {\n                        inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n                    } else if (inlineStyles[range.style]) {\n                        inlineStyles[range.style][i] = true;\n                    }\n                }\n            });\n        }\n        return inlineStyles;\n    }\n    /**\n  * The function will return inline style applicable at some offset within a block.\n  */ function getStylesAtOffset(inlineStyles, offset) {\n        var styles = {};\n        if (inlineStyles.COLOR[offset]) {\n            styles.COLOR = inlineStyles.COLOR[offset];\n        }\n        if (inlineStyles.BGCOLOR[offset]) {\n            styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n        }\n        if (inlineStyles.FONTSIZE[offset]) {\n            styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n        }\n        if (inlineStyles.FONTFAMILY[offset]) {\n            styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n        }\n        if (inlineStyles.UNDERLINE[offset]) {\n            styles.UNDERLINE = true;\n        }\n        if (inlineStyles.ITALIC[offset]) {\n            styles.ITALIC = true;\n        }\n        if (inlineStyles.BOLD[offset]) {\n            styles.BOLD = true;\n        }\n        if (inlineStyles.STRIKETHROUGH[offset]) {\n            styles.STRIKETHROUGH = true;\n        }\n        if (inlineStyles.CODE[offset]) {\n            styles.CODE = true;\n        }\n        if (inlineStyles.SUBSCRIPT[offset]) {\n            styles.SUBSCRIPT = true;\n        }\n        if (inlineStyles.SUPERSCRIPT[offset]) {\n            styles.SUPERSCRIPT = true;\n        }\n        return styles;\n    }\n    /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */ function sameStyleAsPrevious(inlineStyles, styles, index) {\n        var sameStyled = true;\n        if (index > 0 && index < inlineStyles.length) {\n            styles.forEach(function(style) {\n                sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n            });\n        } else {\n            sameStyled = false;\n        }\n        return sameStyled;\n    }\n    /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */ function addInlineStyleMarkup(style, content) {\n        if (style === \"BOLD\") {\n            return \"<strong>\".concat(content, \"</strong>\");\n        }\n        if (style === \"ITALIC\") {\n            return \"<em>\".concat(content, \"</em>\");\n        }\n        if (style === \"UNDERLINE\") {\n            return \"<ins>\".concat(content, \"</ins>\");\n        }\n        if (style === \"STRIKETHROUGH\") {\n            return \"<del>\".concat(content, \"</del>\");\n        }\n        if (style === \"CODE\") {\n            return \"<code>\".concat(content, \"</code>\");\n        }\n        if (style === \"SUPERSCRIPT\") {\n            return \"<sup>\".concat(content, \"</sup>\");\n        }\n        if (style === \"SUBSCRIPT\") {\n            return \"<sub>\".concat(content, \"</sub>\");\n        }\n        return content;\n    }\n    /**\n  * The function returns text for given section of block after doing required character replacements.\n  */ function getSectionText(text) {\n        if (text && text.length > 0) {\n            var chars = text.map(function(ch) {\n                switch(ch){\n                    case \"\\n\":\n                        return \"<br>\";\n                    case \"&\":\n                        return \"&amp;\";\n                    case \"<\":\n                        return \"&lt;\";\n                    case \">\":\n                        return \"&gt;\";\n                    default:\n                        return ch;\n                }\n            });\n            return chars.join(\"\");\n        }\n        return \"\";\n    }\n    /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */ function addStylePropertyMarkup(styles, text) {\n        if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n            var styleString = 'style=\"';\n            if (styles.COLOR) {\n                styleString += \"color: \".concat(styles.COLOR, \";\");\n            }\n            if (styles.BGCOLOR) {\n                styleString += \"background-color: \".concat(styles.BGCOLOR, \";\");\n            }\n            if (styles.FONTSIZE) {\n                styleString += \"font-size: \".concat(styles.FONTSIZE).concat(/^\\d+$/.test(styles.FONTSIZE) ? \"px\" : \"\", \";\");\n            }\n            if (styles.FONTFAMILY) {\n                styleString += \"font-family: \".concat(styles.FONTFAMILY, \";\");\n            }\n            styleString += '\"';\n            return \"<span \".concat(styleString, \">\").concat(text, \"</span>\");\n        }\n        return text;\n    }\n    /**\n  * Function will return markup for Entity.\n  */ function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n        var entity = entityMap[entityKey];\n        if (typeof customEntityTransform === \"function\") {\n            var html = customEntityTransform(entity, text);\n            if (html) {\n                return html;\n            }\n        }\n        if (entity.type === \"MENTION\") {\n            return '<a href=\"'.concat(entity.data.url, '\" class=\"wysiwyg-mention\" data-mention data-value=\"').concat(entity.data.value, '\">').concat(text, \"</a>\");\n        }\n        if (entity.type === \"LINK\") {\n            var targetOption = entity.data.targetOption || \"_self\";\n            return '<a href=\"'.concat(entity.data.url, '\" target=\"').concat(targetOption, '\">').concat(text, \"</a>\");\n        }\n        if (entity.type === \"IMAGE\") {\n            var alignment = entity.data.alignment;\n            if (alignment && alignment.length) {\n                return '<div style=\"text-align:'.concat(alignment, ';\"><img src=\"').concat(entity.data.src, '\" alt=\"').concat(entity.data.alt, '\" style=\"height: ').concat(entity.data.height, \";width: \").concat(entity.data.width, '\"/></div>');\n            }\n            return '<img src=\"'.concat(entity.data.src, '\" alt=\"').concat(entity.data.alt, '\" style=\"height: ').concat(entity.data.height, \";width: \").concat(entity.data.width, '\"/>');\n        }\n        if (entity.type === \"EMBEDDED_LINK\") {\n            return '<iframe width=\"'.concat(entity.data.width, '\" height=\"').concat(entity.data.height, '\" src=\"').concat(entity.data.src, '\" frameBorder=\"0\"></iframe>');\n        }\n        return text;\n    }\n    /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */ function getInlineStyleSections(block, styles, start, end) {\n        var styleSections = [];\n        var text = Array.from(block.text);\n        if (text.length > 0) {\n            var inlineStyles = getStyleArrayForBlock(block);\n            var section;\n            for(var i = start; i < end; i += 1){\n                if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n                    section.text.push(text[i]);\n                    section.end = i + 1;\n                } else {\n                    section = {\n                        styles: getStylesAtOffset(inlineStyles, i),\n                        text: [\n                            text[i]\n                        ],\n                        start: i,\n                        end: i + 1\n                    };\n                    styleSections.push(section);\n                }\n            }\n        }\n        return styleSections;\n    }\n    /**\n  * Replace leading blank spaces by &nbsp;\n  */ function trimLeadingZeros(sectionText) {\n        if (sectionText) {\n            var replacedText = sectionText;\n            for(var i = 0; i < replacedText.length; i += 1){\n                if (sectionText[i] === \" \") {\n                    replacedText = replacedText.replace(\" \", \"&nbsp;\");\n                } else {\n                    break;\n                }\n            }\n            return replacedText;\n        }\n        return sectionText;\n    }\n    /**\n  * Replace trailing blank spaces by &nbsp;\n  */ function trimTrailingZeros(sectionText) {\n        if (sectionText) {\n            var replacedText = sectionText;\n            for(var i = replacedText.length - 1; i >= 0; i -= 1){\n                if (replacedText[i] === \" \") {\n                    replacedText = \"\".concat(replacedText.substring(0, i), \"&nbsp;\").concat(replacedText.substring(i + 1));\n                } else {\n                    break;\n                }\n            }\n            return replacedText;\n        }\n        return sectionText;\n    }\n    /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */ function getStyleTagSectionMarkup(styleSection) {\n        var styles = styleSection.styles, text = styleSection.text;\n        var content = getSectionText(text);\n        forEach(styles, function(style, value) {\n            content = addInlineStyleMarkup(style, content);\n        });\n        return content;\n    }\n    /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */ function getInlineStyleSectionMarkup(block, styleSection) {\n        var styleTagSections = getInlineStyleSections(block, [\n            \"BOLD\",\n            \"ITALIC\",\n            \"UNDERLINE\",\n            \"STRIKETHROUGH\",\n            \"CODE\",\n            \"SUPERSCRIPT\",\n            \"SUBSCRIPT\"\n        ], styleSection.start, styleSection.end);\n        var styleSectionText = \"\";\n        styleTagSections.forEach(function(stylePropertySection) {\n            styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n        });\n        styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n        return styleSectionText;\n    }\n    /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */ function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n        var entityInlineMarkup = [];\n        var inlineStyleSections = getInlineStyleSections(block, [\n            \"COLOR\",\n            \"BGCOLOR\",\n            \"FONTSIZE\",\n            \"FONTFAMILY\"\n        ], section.start, section.end);\n        inlineStyleSections.forEach(function(styleSection) {\n            entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n        });\n        var sectionText = entityInlineMarkup.join(\"\");\n        if (section.type === \"ENTITY\") {\n            if (section.entityKey !== undefined && section.entityKey !== null) {\n                sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n            }\n        } else if (section.type === \"HASHTAG\") {\n            sectionText = '<a href=\"'.concat(sectionText, '\" class=\"wysiwyg-hashtag\">').concat(sectionText, \"</a>\");\n        }\n        return sectionText;\n    }\n    /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */ function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n        var blockMarkup = [];\n        var sections = getSections(block, hashtagConfig);\n        sections.forEach(function(section, index) {\n            var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n            if (index === 0) {\n                sectionText = trimLeadingZeros(sectionText);\n            }\n            if (index === sections.length - 1) {\n                sectionText = trimTrailingZeros(sectionText);\n            }\n            blockMarkup.push(sectionText);\n        });\n        return blockMarkup.join(\"\");\n    }\n    /**\n  * Function will return html for the block.\n  */ function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n        var blockHtml = [];\n        if (isAtomicEntityBlock(block)) {\n            blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n        } else {\n            var blockTag = getBlockTag(block.type);\n            if (blockTag) {\n                blockHtml.push(\"<\".concat(blockTag));\n                var blockStyle = getBlockStyle(block.data);\n                if (blockStyle) {\n                    blockHtml.push(' style=\"'.concat(blockStyle, '\"'));\n                }\n                if (directional) {\n                    blockHtml.push(' dir = \"auto\"');\n                }\n                blockHtml.push(\">\");\n                blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n                blockHtml.push(\"</\".concat(blockTag, \">\"));\n            }\n        }\n        blockHtml.push(\"\\n\");\n        return blockHtml.join(\"\");\n    }\n    /**\n  * Function to check if a block is of type list.\n  */ function isList(blockType) {\n        return blockType === \"unordered-list-item\" || blockType === \"ordered-list-item\";\n    }\n    /**\n  * Function will return html markup for a list block.\n  */ function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n        var listHtml = [];\n        var nestedListBlock = [];\n        var previousBlock;\n        listBlocks.forEach(function(block) {\n            var nestedBlock = false;\n            if (!previousBlock) {\n                listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n            } else if (previousBlock.type !== block.type) {\n                listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n                listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n            } else if (previousBlock.depth === block.depth) {\n                if (nestedListBlock && nestedListBlock.length > 0) {\n                    listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n                    nestedListBlock = [];\n                }\n            } else {\n                nestedBlock = true;\n                nestedListBlock.push(block);\n            }\n            if (!nestedBlock) {\n                listHtml.push(\"<li\");\n                var blockStyle = getBlockStyle(block.data);\n                if (blockStyle) {\n                    listHtml.push(' style=\"'.concat(blockStyle, '\"'));\n                }\n                if (directional) {\n                    listHtml.push(' dir = \"auto\"');\n                }\n                listHtml.push(\">\");\n                listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n                listHtml.push(\"</li>\\n\");\n                previousBlock = block;\n            }\n        });\n        if (nestedListBlock && nestedListBlock.length > 0) {\n            listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n        }\n        listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n        return listHtml.join(\"\");\n    }\n    /**\n  * The function will generate html markup for given draftjs editorContent.\n  */ function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n        var html = [];\n        if (editorContent) {\n            var blocks = editorContent.blocks, entityMap = editorContent.entityMap;\n            if (blocks && blocks.length > 0) {\n                var listBlocks = [];\n                blocks.forEach(function(block) {\n                    if (isList(block.type)) {\n                        listBlocks.push(block);\n                    } else {\n                        if (listBlocks.length > 0) {\n                            var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n                            html.push(listHtml);\n                            listBlocks = [];\n                        }\n                        var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n                        html.push(blockHtml);\n                    }\n                });\n                if (listBlocks.length > 0) {\n                    var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n                    html.push(listHtml);\n                    listBlocks = [];\n                }\n            }\n        }\n        return html.join(\"\");\n    }\n    return draftToHtml;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZHJhZnRqcy10by1odG1sL2xpYi9kcmFmdGpzLXRvLWh0bWwuanMiLCJtYXBwaW5ncyI6IjtBQUFDLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN4QixLQUFpRCxHQUFjRSxPQUFPRCxPQUFPLEdBQUdELFlBQ2hGLENBQzBEO0FBQzVELEdBQUUsUUFBTztJQUFjO0lBRXJCOztFQUVBLEdBQ0EsU0FBU08sUUFBUUMsR0FBRyxFQUFFQyxRQUFRO1FBQzVCLElBQUlELEtBQUs7WUFDUCxJQUFLLElBQUlFLE9BQU9GLElBQUs7Z0JBQ25CLDJDQUEyQztnQkFDM0MsSUFBSSxFQUFDLEdBQUVHLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixLQUFLRSxNQUFNO29CQUNwQ0QsU0FBU0MsS0FBS0YsR0FBRyxDQUFDRSxJQUFJO2dCQUN4QjtZQUNGO1FBQ0Y7SUFDRjtJQUNBOztFQUVBLEdBRUEsU0FBU0csY0FBY0MsR0FBRztRQUN4QixJQUFJQSxRQUFRQyxhQUFhRCxRQUFRLFFBQVFBLElBQUlFLE1BQU0sS0FBSyxLQUFLRixJQUFJRyxJQUFJLEdBQUdELE1BQU0sS0FBSyxHQUFHO1lBQ3BGLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBOztFQUVBLEdBRUEsSUFBSUUsb0JBQW9CO1FBQ3RCQyxVQUFVO1FBQ1YsY0FBYztRQUNkLGNBQWM7UUFDZCxnQkFBZ0I7UUFDaEIsZUFBZTtRQUNmLGVBQWU7UUFDZixjQUFjO1FBQ2QsdUJBQXVCO1FBQ3ZCLHFCQUFxQjtRQUNyQkMsWUFBWTtRQUNaQyxNQUFNO0lBQ1I7SUFDQTs7RUFFQSxHQUVBLFNBQVNDLFlBQVlDLElBQUk7UUFDdkIsT0FBT0EsUUFBUUwsaUJBQWlCLENBQUNLLEtBQUs7SUFDeEM7SUFDQTs7RUFFQSxHQUVBLFNBQVNDLGNBQWNDLElBQUk7UUFDekIsSUFBSUMsU0FBUztRQUNibkIsUUFBUWtCLE1BQU0sU0FBVWYsR0FBRyxFQUFFaUIsS0FBSztZQUNoQyxJQUFJQSxPQUFP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YUFBYSxFQUFFO2dCQUNuQlEsT0FBT25JLE9BQU8sQ0FBQyxTQUFVc0MsS0FBSztvQkFDNUIsSUFBSWtGLE9BQU9sRixNQUFNdEIsSUFBSSxHQUFHO3dCQUN0QjJHLFdBQVd4RixJQUFJLENBQUNHO29CQUNsQixPQUFPO3dCQUNMLElBQUlxRixXQUFXbEgsTUFBTSxHQUFHLEdBQUc7NEJBQ3pCLElBQUltSCxXQUFXRixjQUFjQyxZQUFZdkMsV0FBVzVELGVBQWU2RCx3QkFBd0IsOEJBQThCOzRCQUV6SEUsS0FBS3BELElBQUksQ0FBQ3lGOzRCQUNWRCxhQUFhLEVBQUU7d0JBQ2pCO3dCQUVBLElBQUlOLFlBQVlGLGVBQWU3RSxPQUFPOEMsV0FBVzVELGVBQWU0RixhQUFhL0I7d0JBQzdFRSxLQUFLcEQsSUFBSSxDQUFDa0Y7b0JBQ1o7Z0JBQ0Y7Z0JBRUEsSUFBSU0sV0FBV2xILE1BQU0sR0FBRyxHQUFHO29CQUN6QixJQUFJbUgsV0FBV0YsY0FBY0MsWUFBWXZDLFdBQVc1RCxlQUFlNEYsYUFBYS9CLHdCQUF3Qiw4QkFBOEI7b0JBRXRJRSxLQUFLcEQsSUFBSSxDQUFDeUY7b0JBQ1ZELGFBQWEsRUFBRTtnQkFDakI7WUFDRjtRQUNGO1FBRUEsT0FBT3BDLEtBQUtSLElBQUksQ0FBQztJQUNuQjtJQUVBLE9BQU9rRDtBQUVUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXF1aXAtdmVsby1mb3ItbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2RyYWZ0anMtdG8taHRtbC9saWIvZHJhZnRqcy10by1odG1sLmpzP2Y1NzMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5kcmFmdGpzVG9IdG1sID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZXhlY3V0ZSBjYWxsYmFjayBmb3IgZWFjayBrZXktPnZhbHVlIHBhaXIuXG4gICovXG4gIGZ1bmN0aW9uIGZvckVhY2gob2JqLCBjYWxsYmFjaykge1xuICAgIGlmIChvYmopIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICBjYWxsYmFjayhrZXksIG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgcGFzc2VkIHRvIGl0IGhhcyBubyBjb250ZW50LlxuICAqL1xuXG4gIGZ1bmN0aW9uIGlzRW1wdHlTdHJpbmcoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkIHx8IHN0ciA9PT0gbnVsbCB8fCBzdHIubGVuZ3RoID09PSAwIHx8IHN0ci50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgKiBNYXBwaW5nIGJsb2NrLXR5cGUgdG8gY29ycmVzcG9uZGluZyBodG1sIHRhZy5cbiAgKi9cblxuICB2YXIgYmxvY2tUeXBlc01hcHBpbmcgPSB7XG4gICAgdW5zdHlsZWQ6ICdwJyxcbiAgICAnaGVhZGVyLW9uZSc6ICdoMScsXG4gICAgJ2hlYWRlci10d28nOiAnaDInLFxuICAgICdoZWFkZXItdGhyZWUnOiAnaDMnLFxuICAgICdoZWFkZXItZm91cic6ICdoNCcsXG4gICAgJ2hlYWRlci1maXZlJzogJ2g1JyxcbiAgICAnaGVhZGVyLXNpeCc6ICdoNicsXG4gICAgJ3Vub3JkZXJlZC1saXN0LWl0ZW0nOiAndWwnLFxuICAgICdvcmRlcmVkLWxpc3QtaXRlbSc6ICdvbCcsXG4gICAgYmxvY2txdW90ZTogJ2Jsb2NrcXVvdGUnLFxuICAgIGNvZGU6ICdwcmUnXG4gIH07XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHdpbGwgcmV0dXJuIEhUTUwgdGFnIGZvciBhIGJsb2NrLlxuICAqL1xuXG4gIGZ1bmN0aW9uIGdldEJsb2NrVGFnKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSAmJiBibG9ja1R5cGVzTWFwcGluZ1t0eXBlXTtcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiB3aWxsIHJldHVybiBzdHlsZSBzdHJpbmcgZm9yIGEgYmxvY2suXG4gICovXG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tTdHlsZShkYXRhKSB7XG4gICAgdmFyIHN0eWxlcyA9ICcnO1xuICAgIGZvckVhY2goZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzdHlsZXMgKz0gXCJcIi5jb25jYXQoa2V5LCBcIjpcIikuY29uY2F0KHZhbHVlLCBcIjtcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuICAvKipcbiAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhbiBhcnJheSBvZiBoYXNodGFnLXNlY3Rpb25zIGluIGJsb2Nrcy5cbiAgKiBUaGVzZSB3aWxsIGJlIGFyZWFzIGluIGJsb2NrIHdoaWNoIGhhdmUgaGFzaHRhZ3MgYXBwbGljYWJsZSB0byB0aGVtLlxuICAqL1xuXG4gIGZ1bmN0aW9uIGdldEhhc2h0YWdSYW5nZXMoYmxvY2tUZXh0LCBoYXNodGFnQ29uZmlnKSB7XG4gICAgdmFyIHNlY3Rpb25zID0gW107XG5cbiAgICBpZiAoaGFzaHRhZ0NvbmZpZykge1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgdmFyIHRleHQgPSBibG9ja1RleHQ7XG4gICAgICB2YXIgdHJpZ2dlciA9IGhhc2h0YWdDb25maWcudHJpZ2dlciB8fCAnIyc7XG4gICAgICB2YXIgc2VwYXJhdG9yID0gaGFzaHRhZ0NvbmZpZy5zZXBhcmF0b3IgfHwgJyAnO1xuXG4gICAgICBmb3IgKDsgdGV4dC5sZW5ndGggPiAwICYmIHN0YXJ0SW5kZXggPj0gMDspIHtcbiAgICAgICAgaWYgKHRleHRbMF0gPT09IHRyaWdnZXIpIHtcbiAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICBjb3VudGVyID0gMDtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIodHJpZ2dlci5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0SW5kZXggPSB0ZXh0LmluZGV4T2Yoc2VwYXJhdG9yICsgdHJpZ2dlcik7XG5cbiAgICAgICAgICBpZiAoc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIoc3RhcnRJbmRleCArIChzZXBhcmF0b3IgKyB0cmlnZ2VyKS5sZW5ndGgpO1xuICAgICAgICAgICAgY291bnRlciArPSBzdGFydEluZGV4ICsgc2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgdmFyIGVuZEluZGV4ID0gdGV4dC5pbmRleE9mKHNlcGFyYXRvcikgPj0gMCA/IHRleHQuaW5kZXhPZihzZXBhcmF0b3IpIDogdGV4dC5sZW5ndGg7XG4gICAgICAgICAgdmFyIGhhc2h0YWcgPSB0ZXh0LnN1YnN0cigwLCBlbmRJbmRleCk7XG5cbiAgICAgICAgICBpZiAoaGFzaHRhZyAmJiBoYXNodGFnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICBvZmZzZXQ6IGNvdW50ZXIsXG4gICAgICAgICAgICAgIGxlbmd0aDogaGFzaHRhZy5sZW5ndGggKyB0cmlnZ2VyLmxlbmd0aCxcbiAgICAgICAgICAgICAgdHlwZTogJ0hBU0hUQUcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb3VudGVyICs9IHRyaWdnZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb25zO1xuICB9XG4gIC8qKlxuICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFuIGFycmF5IG9mIGVudGl0eS1zZWN0aW9ucyBpbiBibG9ja3MuXG4gICogVGhlc2Ugd2lsbCBiZSBhcmVhcyBpbiBibG9jayB3aGljaCBoYXZlIHNhbWUgZW50aXR5IG9yIG5vIGVudGl0eSBhcHBsaWNhYmxlIHRvIHRoZW0uXG4gICovXG5cblxuICBmdW5jdGlvbiBnZXRTZWN0aW9ucyhibG9jaywgaGFzaHRhZ0NvbmZpZykge1xuICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICB2YXIgc2VjdGlvblJhbmdlcyA9IGJsb2NrLmVudGl0eVJhbmdlcy5tYXAoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gcmFuZ2Uub2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aCA9IHJhbmdlLmxlbmd0aCxcbiAgICAgICAgICBrZXkgPSByYW5nZS5rZXk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB0eXBlOiAnRU5USVRZJ1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBzZWN0aW9uUmFuZ2VzID0gc2VjdGlvblJhbmdlcy5jb25jYXQoZ2V0SGFzaHRhZ1JhbmdlcyhibG9jay50ZXh0LCBoYXNodGFnQ29uZmlnKSk7XG4gICAgc2VjdGlvblJhbmdlcyA9IHNlY3Rpb25SYW5nZXMuc29ydChmdW5jdGlvbiAoczEsIHMyKSB7XG4gICAgICByZXR1cm4gczEub2Zmc2V0IC0gczIub2Zmc2V0O1xuICAgIH0pO1xuICAgIHNlY3Rpb25SYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgaWYgKHIub2Zmc2V0ID4gbGFzdE9mZnNldCkge1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBzdGFydDogbGFzdE9mZnNldCxcbiAgICAgICAgICBlbmQ6IHIub2Zmc2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IHIub2Zmc2V0LFxuICAgICAgICBlbmQ6IHIub2Zmc2V0ICsgci5sZW5ndGgsXG4gICAgICAgIGVudGl0eUtleTogci5rZXksXG4gICAgICAgIHR5cGU6IHIudHlwZVxuICAgICAgfSk7XG4gICAgICBsYXN0T2Zmc2V0ID0gci5vZmZzZXQgKyByLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIGlmIChsYXN0T2Zmc2V0IDwgYmxvY2sudGV4dC5sZW5ndGgpIHtcbiAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICBzdGFydDogbGFzdE9mZnNldCxcbiAgICAgICAgZW5kOiBibG9jay50ZXh0Lmxlbmd0aFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb25zO1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBibG9jayBpcyBhbiBhdG9taWMgZW50aXR5IGJsb2NrLlxuICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNBdG9taWNFbnRpdHlCbG9jayhibG9jaykge1xuICAgIGlmIChibG9jay5lbnRpdHlSYW5nZXMubGVuZ3RoID4gMCAmJiAoaXNFbXB0eVN0cmluZyhibG9jay50ZXh0KSB8fCBibG9jay50eXBlID09PSAnYXRvbWljJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBUaGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYXJyYXkgb2YgaW5saW5lIHN0eWxlcyBhcHBsaWNhYmxlIHRvIHRoZSBibG9jay5cbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFN0eWxlQXJyYXlGb3JCbG9jayhibG9jaykge1xuICAgIHZhciB0ZXh0ID0gYmxvY2sudGV4dCxcbiAgICAgICAgaW5saW5lU3R5bGVSYW5nZXMgPSBibG9jay5pbmxpbmVTdHlsZVJhbmdlcztcbiAgICB2YXIgaW5saW5lU3R5bGVzID0ge1xuICAgICAgQk9MRDogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIElUQUxJQzogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIFVOREVSTElORTogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIFNUUklLRVRIUk9VR0g6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBDT0RFOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgU1VQRVJTQ1JJUFQ6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBTVUJTQ1JJUFQ6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBDT0xPUjogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIEJHQ09MT1I6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBGT05UU0laRTogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIEZPTlRGQU1JTFk6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBsZW5ndGg6IHRleHQubGVuZ3RoXG4gICAgfTtcblxuICAgIGlmIChpbmxpbmVTdHlsZVJhbmdlcyAmJiBpbmxpbmVTdHlsZVJhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICBpbmxpbmVTdHlsZVJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcmFuZ2Uub2Zmc2V0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gb2Zmc2V0ICsgcmFuZ2UubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChyYW5nZS5zdHlsZS5pbmRleE9mKCdjb2xvci0nKSA9PT0gMCkge1xuICAgICAgICAgICAgaW5saW5lU3R5bGVzLkNPTE9SW2ldID0gcmFuZ2Uuc3R5bGUuc3Vic3RyaW5nKDYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2Uuc3R5bGUuaW5kZXhPZignYmdjb2xvci0nKSA9PT0gMCkge1xuICAgICAgICAgICAgaW5saW5lU3R5bGVzLkJHQ09MT1JbaV0gPSByYW5nZS5zdHlsZS5zdWJzdHJpbmcoOCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5zdHlsZS5pbmRleE9mKCdmb250c2l6ZS0nKSA9PT0gMCkge1xuICAgICAgICAgICAgaW5saW5lU3R5bGVzLkZPTlRTSVpFW2ldID0gcmFuZ2Uuc3R5bGUuc3Vic3RyaW5nKDkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2Uuc3R5bGUuaW5kZXhPZignZm9udGZhbWlseS0nKSA9PT0gMCkge1xuICAgICAgICAgICAgaW5saW5lU3R5bGVzLkZPTlRGQU1JTFlbaV0gPSByYW5nZS5zdHlsZS5zdWJzdHJpbmcoMTEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5saW5lU3R5bGVzW3JhbmdlLnN0eWxlXSkge1xuICAgICAgICAgICAgaW5saW5lU3R5bGVzW3JhbmdlLnN0eWxlXVtpXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5saW5lU3R5bGVzO1xuICB9XG4gIC8qKlxuICAqIFRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBpbmxpbmUgc3R5bGUgYXBwbGljYWJsZSBhdCBzb21lIG9mZnNldCB3aXRoaW4gYSBibG9jay5cbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFN0eWxlc0F0T2Zmc2V0KGlubGluZVN0eWxlcywgb2Zmc2V0KSB7XG4gICAgdmFyIHN0eWxlcyA9IHt9O1xuXG4gICAgaWYgKGlubGluZVN0eWxlcy5DT0xPUltvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuQ09MT1IgPSBpbmxpbmVTdHlsZXMuQ09MT1Jbb2Zmc2V0XTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLkJHQ09MT1Jbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLkJHQ09MT1IgPSBpbmxpbmVTdHlsZXMuQkdDT0xPUltvZmZzZXRdO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuRk9OVFNJWkVbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLkZPTlRTSVpFID0gaW5saW5lU3R5bGVzLkZPTlRTSVpFW29mZnNldF07XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5GT05URkFNSUxZW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5GT05URkFNSUxZID0gaW5saW5lU3R5bGVzLkZPTlRGQU1JTFlbb2Zmc2V0XTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLlVOREVSTElORVtvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuVU5ERVJMSU5FID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLklUQUxJQ1tvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuSVRBTElDID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLkJPTERbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLkJPTEQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuU1RSSUtFVEhST1VHSFtvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuU1RSSUtFVEhST1VHSCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5DT0RFW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5DT0RFID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLlNVQlNDUklQVFtvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuU1VCU0NSSVBUID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLlNVUEVSU0NSSVBUW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5TVVBFUlNDUklQVCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiByZXR1cm5zIHRydWUgZm9yIGEgc2V0IG9mIHN0eWxlcyBpZiB0aGUgdmFsdWUgb2YgdGhlc2Ugc3R5bGVzIGF0IGFuIG9mZnNldFxuICAqIGFyZSBzYW1lIGFzIHRoYXQgb24gdGhlIHByZXZpb3VzIG9mZnNldC5cbiAgKi9cblxuICBmdW5jdGlvbiBzYW1lU3R5bGVBc1ByZXZpb3VzKGlubGluZVN0eWxlcywgc3R5bGVzLCBpbmRleCkge1xuICAgIHZhciBzYW1lU3R5bGVkID0gdHJ1ZTtcblxuICAgIGlmIChpbmRleCA+IDAgJiYgaW5kZXggPCBpbmxpbmVTdHlsZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgc2FtZVN0eWxlZCA9IHNhbWVTdHlsZWQgJiYgaW5saW5lU3R5bGVzW3N0eWxlXVtpbmRleF0gPT09IGlubGluZVN0eWxlc1tzdHlsZV1baW5kZXggLSAxXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYW1lU3R5bGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNhbWVTdHlsZWQ7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gcmV0dXJucyBodG1sIGZvciB0ZXh0IGRlcGVuZGluZyBvbiBpbmxpbmUgc3R5bGUgdGFncyBhcHBsaWNhYmxlIHRvIGl0LlxuICAqL1xuXG4gIGZ1bmN0aW9uIGFkZElubGluZVN0eWxlTWFya3VwKHN0eWxlLCBjb250ZW50KSB7XG4gICAgaWYgKHN0eWxlID09PSAnQk9MRCcpIHtcbiAgICAgIHJldHVybiBcIjxzdHJvbmc+XCIuY29uY2F0KGNvbnRlbnQsIFwiPC9zdHJvbmc+XCIpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZSA9PT0gJ0lUQUxJQycpIHtcbiAgICAgIHJldHVybiBcIjxlbT5cIi5jb25jYXQoY29udGVudCwgXCI8L2VtPlwiKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUgPT09ICdVTkRFUkxJTkUnKSB7XG4gICAgICByZXR1cm4gXCI8aW5zPlwiLmNvbmNhdChjb250ZW50LCBcIjwvaW5zPlwiKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUgPT09ICdTVFJJS0VUSFJPVUdIJykge1xuICAgICAgcmV0dXJuIFwiPGRlbD5cIi5jb25jYXQoY29udGVudCwgXCI8L2RlbD5cIik7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlID09PSAnQ09ERScpIHtcbiAgICAgIHJldHVybiBcIjxjb2RlPlwiLmNvbmNhdChjb250ZW50LCBcIjwvY29kZT5cIik7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlID09PSAnU1VQRVJTQ1JJUFQnKSB7XG4gICAgICByZXR1cm4gXCI8c3VwPlwiLmNvbmNhdChjb250ZW50LCBcIjwvc3VwPlwiKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUgPT09ICdTVUJTQ1JJUFQnKSB7XG4gICAgICByZXR1cm4gXCI8c3ViPlwiLmNvbmNhdChjb250ZW50LCBcIjwvc3ViPlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICAvKipcbiAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0ZXh0IGZvciBnaXZlbiBzZWN0aW9uIG9mIGJsb2NrIGFmdGVyIGRvaW5nIHJlcXVpcmVkIGNoYXJhY3RlciByZXBsYWNlbWVudHMuXG4gICovXG5cbiAgZnVuY3Rpb24gZ2V0U2VjdGlvblRleHQodGV4dCkge1xuICAgIGlmICh0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGNoYXJzID0gdGV4dC5tYXAoZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgcmV0dXJuICc8YnI+JztcblxuICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICcmYW1wOyc7XG5cbiAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIHJldHVybiAnJmx0Oyc7XG5cbiAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gcmV0dXJucyBodG1sIGZvciB0ZXh0IGRlcGVuZGluZyBvbiBpbmxpbmUgc3R5bGUgdGFncyBhcHBsaWNhYmxlIHRvIGl0LlxuICAqL1xuXG5cbiAgZnVuY3Rpb24gYWRkU3R5bGVQcm9wZXJ0eU1hcmt1cChzdHlsZXMsIHRleHQpIHtcbiAgICBpZiAoc3R5bGVzICYmIChzdHlsZXMuQ09MT1IgfHwgc3R5bGVzLkJHQ09MT1IgfHwgc3R5bGVzLkZPTlRTSVpFIHx8IHN0eWxlcy5GT05URkFNSUxZKSkge1xuICAgICAgdmFyIHN0eWxlU3RyaW5nID0gJ3N0eWxlPVwiJztcblxuICAgICAgaWYgKHN0eWxlcy5DT0xPUikge1xuICAgICAgICBzdHlsZVN0cmluZyArPSBcImNvbG9yOiBcIi5jb25jYXQoc3R5bGVzLkNPTE9SLCBcIjtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZXMuQkdDT0xPUikge1xuICAgICAgICBzdHlsZVN0cmluZyArPSBcImJhY2tncm91bmQtY29sb3I6IFwiLmNvbmNhdChzdHlsZXMuQkdDT0xPUiwgXCI7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGVzLkZPTlRTSVpFKSB7XG4gICAgICAgIHN0eWxlU3RyaW5nICs9IFwiZm9udC1zaXplOiBcIi5jb25jYXQoc3R5bGVzLkZPTlRTSVpFKS5jb25jYXQoL15cXGQrJC8udGVzdChzdHlsZXMuRk9OVFNJWkUpID8gJ3B4JyA6ICcnLCBcIjtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZXMuRk9OVEZBTUlMWSkge1xuICAgICAgICBzdHlsZVN0cmluZyArPSBcImZvbnQtZmFtaWx5OiBcIi5jb25jYXQoc3R5bGVzLkZPTlRGQU1JTFksIFwiO1wiKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVTdHJpbmcgKz0gJ1wiJztcbiAgICAgIHJldHVybiBcIjxzcGFuIFwiLmNvbmNhdChzdHlsZVN0cmluZywgXCI+XCIpLmNvbmNhdCh0ZXh0LCBcIjwvc3Bhbj5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gd2lsbCByZXR1cm4gbWFya3VwIGZvciBFbnRpdHkuXG4gICovXG5cbiAgZnVuY3Rpb24gZ2V0RW50aXR5TWFya3VwKGVudGl0eU1hcCwgZW50aXR5S2V5LCB0ZXh0LCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pIHtcbiAgICB2YXIgZW50aXR5ID0gZW50aXR5TWFwW2VudGl0eUtleV07XG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbUVudGl0eVRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGh0bWwgPSBjdXN0b21FbnRpdHlUcmFuc2Zvcm0oZW50aXR5LCB0ZXh0KTtcblxuICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudGl0eS50eXBlID09PSAnTUVOVElPTicpIHtcbiAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIlwiLmNvbmNhdChlbnRpdHkuZGF0YS51cmwsIFwiXFxcIiBjbGFzcz1cXFwid3lzaXd5Zy1tZW50aW9uXFxcIiBkYXRhLW1lbnRpb24gZGF0YS12YWx1ZT1cXFwiXCIpLmNvbmNhdChlbnRpdHkuZGF0YS52YWx1ZSwgXCJcXFwiPlwiKS5jb25jYXQodGV4dCwgXCI8L2E+XCIpO1xuICAgIH1cblxuICAgIGlmIChlbnRpdHkudHlwZSA9PT0gJ0xJTksnKSB7XG4gICAgICB2YXIgdGFyZ2V0T3B0aW9uID0gZW50aXR5LmRhdGEudGFyZ2V0T3B0aW9uIHx8ICdfc2VsZic7XG4gICAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJcIi5jb25jYXQoZW50aXR5LmRhdGEudXJsLCBcIlxcXCIgdGFyZ2V0PVxcXCJcIikuY29uY2F0KHRhcmdldE9wdGlvbiwgXCJcXFwiPlwiKS5jb25jYXQodGV4dCwgXCI8L2E+XCIpO1xuICAgIH1cblxuICAgIGlmIChlbnRpdHkudHlwZSA9PT0gJ0lNQUdFJykge1xuICAgICAgdmFyIGFsaWdubWVudCA9IGVudGl0eS5kYXRhLmFsaWdubWVudDtcblxuICAgICAgaWYgKGFsaWdubWVudCAmJiBhbGlnbm1lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBcIjxkaXYgc3R5bGU9XFxcInRleHQtYWxpZ246XCIuY29uY2F0KGFsaWdubWVudCwgXCI7XFxcIj48aW1nIHNyYz1cXFwiXCIpLmNvbmNhdChlbnRpdHkuZGF0YS5zcmMsIFwiXFxcIiBhbHQ9XFxcIlwiKS5jb25jYXQoZW50aXR5LmRhdGEuYWx0LCBcIlxcXCIgc3R5bGU9XFxcImhlaWdodDogXCIpLmNvbmNhdChlbnRpdHkuZGF0YS5oZWlnaHQsIFwiO3dpZHRoOiBcIikuY29uY2F0KGVudGl0eS5kYXRhLndpZHRoLCBcIlxcXCIvPjwvZGl2PlwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiPGltZyBzcmM9XFxcIlwiLmNvbmNhdChlbnRpdHkuZGF0YS5zcmMsIFwiXFxcIiBhbHQ9XFxcIlwiKS5jb25jYXQoZW50aXR5LmRhdGEuYWx0LCBcIlxcXCIgc3R5bGU9XFxcImhlaWdodDogXCIpLmNvbmNhdChlbnRpdHkuZGF0YS5oZWlnaHQsIFwiO3dpZHRoOiBcIikuY29uY2F0KGVudGl0eS5kYXRhLndpZHRoLCBcIlxcXCIvPlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZW50aXR5LnR5cGUgPT09ICdFTUJFRERFRF9MSU5LJykge1xuICAgICAgcmV0dXJuIFwiPGlmcmFtZSB3aWR0aD1cXFwiXCIuY29uY2F0KGVudGl0eS5kYXRhLndpZHRoLCBcIlxcXCIgaGVpZ2h0PVxcXCJcIikuY29uY2F0KGVudGl0eS5kYXRhLmhlaWdodCwgXCJcXFwiIHNyYz1cXFwiXCIpLmNvbmNhdChlbnRpdHkuZGF0YS5zcmMsIFwiXFxcIiBmcmFtZUJvcmRlcj1cXFwiMFxcXCI+PC9pZnJhbWU+XCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIC8qKlxuICAqIEZvciBhIGdpdmVuIHNlY3Rpb24gaW4gYSBibG9jayB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBmdXJ0aGVyIGxpc3Qgb2Ygc2VjdGlvbnMsXG4gICogd2l0aCBzaW1pbGFyIGlubGluZSBzdHlsZXMgYXBwbGljYWJsZSB0byB0aGVtLlxuICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0SW5saW5lU3R5bGVTZWN0aW9ucyhibG9jaywgc3R5bGVzLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHN0eWxlU2VjdGlvbnMgPSBbXTtcbiAgICB2YXIgdGV4dCA9IEFycmF5LmZyb20oYmxvY2sudGV4dCk7XG5cbiAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaW5saW5lU3R5bGVzID0gZ2V0U3R5bGVBcnJheUZvckJsb2NrKGJsb2NrKTtcbiAgICAgIHZhciBzZWN0aW9uO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaSAhPT0gc3RhcnQgJiYgc2FtZVN0eWxlQXNQcmV2aW91cyhpbmxpbmVTdHlsZXMsIHN0eWxlcywgaSkpIHtcbiAgICAgICAgICBzZWN0aW9uLnRleHQucHVzaCh0ZXh0W2ldKTtcbiAgICAgICAgICBzZWN0aW9uLmVuZCA9IGkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlY3Rpb24gPSB7XG4gICAgICAgICAgICBzdHlsZXM6IGdldFN0eWxlc0F0T2Zmc2V0KGlubGluZVN0eWxlcywgaSksXG4gICAgICAgICAgICB0ZXh0OiBbdGV4dFtpXV0sXG4gICAgICAgICAgICBzdGFydDogaSxcbiAgICAgICAgICAgIGVuZDogaSArIDFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHN0eWxlU2VjdGlvbnMucHVzaChzZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZVNlY3Rpb25zO1xuICB9XG4gIC8qKlxuICAqIFJlcGxhY2UgbGVhZGluZyBibGFuayBzcGFjZXMgYnkgJm5ic3A7XG4gICovXG5cblxuICBmdW5jdGlvbiB0cmltTGVhZGluZ1plcm9zKHNlY3Rpb25UZXh0KSB7XG4gICAgaWYgKHNlY3Rpb25UZXh0KSB7XG4gICAgICB2YXIgcmVwbGFjZWRUZXh0ID0gc2VjdGlvblRleHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZWRUZXh0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChzZWN0aW9uVGV4dFtpXSA9PT0gJyAnKSB7XG4gICAgICAgICAgcmVwbGFjZWRUZXh0ID0gcmVwbGFjZWRUZXh0LnJlcGxhY2UoJyAnLCAnJm5ic3A7Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcGxhY2VkVGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvblRleHQ7XG4gIH1cbiAgLyoqXG4gICogUmVwbGFjZSB0cmFpbGluZyBibGFuayBzcGFjZXMgYnkgJm5ic3A7XG4gICovXG5cbiAgZnVuY3Rpb24gdHJpbVRyYWlsaW5nWmVyb3Moc2VjdGlvblRleHQpIHtcbiAgICBpZiAoc2VjdGlvblRleHQpIHtcbiAgICAgIHZhciByZXBsYWNlZFRleHQgPSBzZWN0aW9uVGV4dDtcblxuICAgICAgZm9yICh2YXIgaSA9IHJlcGxhY2VkVGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBpZiAocmVwbGFjZWRUZXh0W2ldID09PSAnICcpIHtcbiAgICAgICAgICByZXBsYWNlZFRleHQgPSBcIlwiLmNvbmNhdChyZXBsYWNlZFRleHQuc3Vic3RyaW5nKDAsIGkpLCBcIiZuYnNwO1wiKS5jb25jYXQocmVwbGFjZWRUZXh0LnN1YnN0cmluZyhpICsgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXBsYWNlZFRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb25UZXh0O1xuICB9XG4gIC8qKlxuICAqIFRoZSBtZXRob2QgcmV0dXJucyBtYXJrdXAgZm9yIHNlY3Rpb24gdG8gd2hpY2ggaW5saW5lIHN0eWxlc1xuICAqIGxpa2UgQk9MRCwgSVRBTElDLCBVTkRFUkxJTkUsIFNUUklLRVRIUk9VR0gsIENPREUsIFNVUEVSU0NSSVBULCBTVUJTQ1JJUFQgYXJlIGFwcGxpY2FibGUuXG4gICovXG5cbiAgZnVuY3Rpb24gZ2V0U3R5bGVUYWdTZWN0aW9uTWFya3VwKHN0eWxlU2VjdGlvbikge1xuICAgIHZhciBzdHlsZXMgPSBzdHlsZVNlY3Rpb24uc3R5bGVzLFxuICAgICAgICB0ZXh0ID0gc3R5bGVTZWN0aW9uLnRleHQ7XG4gICAgdmFyIGNvbnRlbnQgPSBnZXRTZWN0aW9uVGV4dCh0ZXh0KTtcbiAgICBmb3JFYWNoKHN0eWxlcywgZnVuY3Rpb24gKHN0eWxlLCB2YWx1ZSkge1xuICAgICAgY29udGVudCA9IGFkZElubGluZVN0eWxlTWFya3VwKHN0eWxlLCBjb250ZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICAvKipcbiAgKiBUaGUgbWV0aG9kIHJldHVybnMgbWFya3VwIGZvciBzZWN0aW9uIHRvIHdoaWNoIGlubGluZSBzdHlsZXNcbiAgbGlrZSBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgZm9udC1zaXplIGFyZSBhcHBsaWNhYmxlLlxuICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0SW5saW5lU3R5bGVTZWN0aW9uTWFya3VwKGJsb2NrLCBzdHlsZVNlY3Rpb24pIHtcbiAgICB2YXIgc3R5bGVUYWdTZWN0aW9ucyA9IGdldElubGluZVN0eWxlU2VjdGlvbnMoYmxvY2ssIFsnQk9MRCcsICdJVEFMSUMnLCAnVU5ERVJMSU5FJywgJ1NUUklLRVRIUk9VR0gnLCAnQ09ERScsICdTVVBFUlNDUklQVCcsICdTVUJTQ1JJUFQnXSwgc3R5bGVTZWN0aW9uLnN0YXJ0LCBzdHlsZVNlY3Rpb24uZW5kKTtcbiAgICB2YXIgc3R5bGVTZWN0aW9uVGV4dCA9ICcnO1xuICAgIHN0eWxlVGFnU2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVQcm9wZXJ0eVNlY3Rpb24pIHtcbiAgICAgIHN0eWxlU2VjdGlvblRleHQgKz0gZ2V0U3R5bGVUYWdTZWN0aW9uTWFya3VwKHN0eWxlUHJvcGVydHlTZWN0aW9uKTtcbiAgICB9KTtcbiAgICBzdHlsZVNlY3Rpb25UZXh0ID0gYWRkU3R5bGVQcm9wZXJ0eU1hcmt1cChzdHlsZVNlY3Rpb24uc3R5bGVzLCBzdHlsZVNlY3Rpb25UZXh0KTtcbiAgICByZXR1cm4gc3R5bGVTZWN0aW9uVGV4dDtcbiAgfVxuICAvKlxuICAqIFRoZSBtZXRob2QgcmV0dXJucyBtYXJrdXAgZm9yIGFuIGVudGl0eSBzZWN0aW9uLlxuICAqIEFuIGVudGl0eSBzZWN0aW9uIGlzIGEgY29udGludW91cyBzZWN0aW9uIGluIGEgYmxvY2tcbiAgKiB0byB3aGljaCBzYW1lIGVudGl0eSBvciBubyBlbnRpdHkgaXMgYXBwbGljYWJsZS5cbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFNlY3Rpb25NYXJrdXAoYmxvY2ssIGVudGl0eU1hcCwgc2VjdGlvbiwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSB7XG4gICAgdmFyIGVudGl0eUlubGluZU1hcmt1cCA9IFtdO1xuICAgIHZhciBpbmxpbmVTdHlsZVNlY3Rpb25zID0gZ2V0SW5saW5lU3R5bGVTZWN0aW9ucyhibG9jaywgWydDT0xPUicsICdCR0NPTE9SJywgJ0ZPTlRTSVpFJywgJ0ZPTlRGQU1JTFknXSwgc2VjdGlvbi5zdGFydCwgc2VjdGlvbi5lbmQpO1xuICAgIGlubGluZVN0eWxlU2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVTZWN0aW9uKSB7XG4gICAgICBlbnRpdHlJbmxpbmVNYXJrdXAucHVzaChnZXRJbmxpbmVTdHlsZVNlY3Rpb25NYXJrdXAoYmxvY2ssIHN0eWxlU2VjdGlvbikpO1xuICAgIH0pO1xuICAgIHZhciBzZWN0aW9uVGV4dCA9IGVudGl0eUlubGluZU1hcmt1cC5qb2luKCcnKTtcblxuICAgIGlmIChzZWN0aW9uLnR5cGUgPT09ICdFTlRJVFknKSB7XG4gICAgICBpZiAoc2VjdGlvbi5lbnRpdHlLZXkgIT09IHVuZGVmaW5lZCAmJiBzZWN0aW9uLmVudGl0eUtleSAhPT0gbnVsbCkge1xuICAgICAgICBzZWN0aW9uVGV4dCA9IGdldEVudGl0eU1hcmt1cChlbnRpdHlNYXAsIHNlY3Rpb24uZW50aXR5S2V5LCBzZWN0aW9uVGV4dCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZWN0aW9uLnR5cGUgPT09ICdIQVNIVEFHJykge1xuICAgICAgc2VjdGlvblRleHQgPSBcIjxhIGhyZWY9XFxcIlwiLmNvbmNhdChzZWN0aW9uVGV4dCwgXCJcXFwiIGNsYXNzPVxcXCJ3eXNpd3lnLWhhc2h0YWdcXFwiPlwiKS5jb25jYXQoc2VjdGlvblRleHQsIFwiPC9hPlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvblRleHQ7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIG1hcmt1cCBmb3IgYmxvY2sgcHJlc2VydmluZyB0aGUgaW5saW5lIHN0eWxlcyBhbmRcbiAgKiBzcGVjaWFsIGNoYXJhY3RlcnMgbGlrZSBuZXdsaW5lcyBvciBibGFuayBzcGFjZXMuXG4gICovXG5cblxuICBmdW5jdGlvbiBnZXRCbG9ja0lubmVyTWFya3VwKGJsb2NrLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkge1xuICAgIHZhciBibG9ja01hcmt1cCA9IFtdO1xuICAgIHZhciBzZWN0aW9ucyA9IGdldFNlY3Rpb25zKGJsb2NrLCBoYXNodGFnQ29uZmlnKTtcbiAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzZWN0aW9uLCBpbmRleCkge1xuICAgICAgdmFyIHNlY3Rpb25UZXh0ID0gZ2V0U2VjdGlvbk1hcmt1cChibG9jaywgZW50aXR5TWFwLCBzZWN0aW9uLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pO1xuXG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgc2VjdGlvblRleHQgPSB0cmltTGVhZGluZ1plcm9zKHNlY3Rpb25UZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSBzZWN0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHNlY3Rpb25UZXh0ID0gdHJpbVRyYWlsaW5nWmVyb3Moc2VjdGlvblRleHQpO1xuICAgICAgfVxuXG4gICAgICBibG9ja01hcmt1cC5wdXNoKHNlY3Rpb25UZXh0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmxvY2tNYXJrdXAuam9pbignJyk7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gd2lsbCByZXR1cm4gaHRtbCBmb3IgdGhlIGJsb2NrLlxuICAqL1xuXG4gIGZ1bmN0aW9uIGdldEJsb2NrTWFya3VwKGJsb2NrLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGRpcmVjdGlvbmFsLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pIHtcbiAgICB2YXIgYmxvY2tIdG1sID0gW107XG5cbiAgICBpZiAoaXNBdG9taWNFbnRpdHlCbG9jayhibG9jaykpIHtcbiAgICAgIGJsb2NrSHRtbC5wdXNoKGdldEVudGl0eU1hcmt1cChlbnRpdHlNYXAsIGJsb2NrLmVudGl0eVJhbmdlc1swXS5rZXksIHVuZGVmaW5lZCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBibG9ja1RhZyA9IGdldEJsb2NrVGFnKGJsb2NrLnR5cGUpO1xuXG4gICAgICBpZiAoYmxvY2tUYWcpIHtcbiAgICAgICAgYmxvY2tIdG1sLnB1c2goXCI8XCIuY29uY2F0KGJsb2NrVGFnKSk7XG4gICAgICAgIHZhciBibG9ja1N0eWxlID0gZ2V0QmxvY2tTdHlsZShibG9jay5kYXRhKTtcblxuICAgICAgICBpZiAoYmxvY2tTdHlsZSkge1xuICAgICAgICAgIGJsb2NrSHRtbC5wdXNoKFwiIHN0eWxlPVxcXCJcIi5jb25jYXQoYmxvY2tTdHlsZSwgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXJlY3Rpb25hbCkge1xuICAgICAgICAgIGJsb2NrSHRtbC5wdXNoKCcgZGlyID0gXCJhdXRvXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJsb2NrSHRtbC5wdXNoKCc+Jyk7XG4gICAgICAgIGJsb2NrSHRtbC5wdXNoKGdldEJsb2NrSW5uZXJNYXJrdXAoYmxvY2ssIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSk7XG4gICAgICAgIGJsb2NrSHRtbC5wdXNoKFwiPC9cIi5jb25jYXQoYmxvY2tUYWcsIFwiPlwiKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmxvY2tIdG1sLnB1c2goJ1xcbicpO1xuICAgIHJldHVybiBibG9ja0h0bWwuam9pbignJyk7XG4gIH1cblxuICAvKipcbiAgKiBGdW5jdGlvbiB0byBjaGVjayBpZiBhIGJsb2NrIGlzIG9mIHR5cGUgbGlzdC5cbiAgKi9cblxuICBmdW5jdGlvbiBpc0xpc3QoYmxvY2tUeXBlKSB7XG4gICAgcmV0dXJuIGJsb2NrVHlwZSA9PT0gJ3Vub3JkZXJlZC1saXN0LWl0ZW0nIHx8IGJsb2NrVHlwZSA9PT0gJ29yZGVyZWQtbGlzdC1pdGVtJztcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiB3aWxsIHJldHVybiBodG1sIG1hcmt1cCBmb3IgYSBsaXN0IGJsb2NrLlxuICAqL1xuXG4gIGZ1bmN0aW9uIGdldExpc3RNYXJrdXAobGlzdEJsb2NrcywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBkaXJlY3Rpb25hbCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSB7XG4gICAgdmFyIGxpc3RIdG1sID0gW107XG4gICAgdmFyIG5lc3RlZExpc3RCbG9jayA9IFtdO1xuICAgIHZhciBwcmV2aW91c0Jsb2NrO1xuICAgIGxpc3RCbG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgIHZhciBuZXN0ZWRCbG9jayA9IGZhbHNlO1xuXG4gICAgICBpZiAoIXByZXZpb3VzQmxvY2spIHtcbiAgICAgICAgbGlzdEh0bWwucHVzaChcIjxcIi5jb25jYXQoZ2V0QmxvY2tUYWcoYmxvY2sudHlwZSksIFwiPlxcblwiKSk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzQmxvY2sudHlwZSAhPT0gYmxvY2sudHlwZSkge1xuICAgICAgICBsaXN0SHRtbC5wdXNoKFwiPC9cIi5jb25jYXQoZ2V0QmxvY2tUYWcocHJldmlvdXNCbG9jay50eXBlKSwgXCI+XFxuXCIpKTtcbiAgICAgICAgbGlzdEh0bWwucHVzaChcIjxcIi5jb25jYXQoZ2V0QmxvY2tUYWcoYmxvY2sudHlwZSksIFwiPlxcblwiKSk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzQmxvY2suZGVwdGggPT09IGJsb2NrLmRlcHRoKSB7XG4gICAgICAgIGlmIChuZXN0ZWRMaXN0QmxvY2sgJiYgbmVzdGVkTGlzdEJsb2NrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsaXN0SHRtbC5wdXNoKGdldExpc3RNYXJrdXAobmVzdGVkTGlzdEJsb2NrLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGRpcmVjdGlvbmFsLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pKTtcbiAgICAgICAgICBuZXN0ZWRMaXN0QmxvY2sgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVzdGVkQmxvY2sgPSB0cnVlO1xuICAgICAgICBuZXN0ZWRMaXN0QmxvY2sucHVzaChibG9jayk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbmVzdGVkQmxvY2spIHtcbiAgICAgICAgbGlzdEh0bWwucHVzaCgnPGxpJyk7XG4gICAgICAgIHZhciBibG9ja1N0eWxlID0gZ2V0QmxvY2tTdHlsZShibG9jay5kYXRhKTtcblxuICAgICAgICBpZiAoYmxvY2tTdHlsZSkge1xuICAgICAgICAgIGxpc3RIdG1sLnB1c2goXCIgc3R5bGU9XFxcIlwiLmNvbmNhdChibG9ja1N0eWxlLCBcIlxcXCJcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbmFsKSB7XG4gICAgICAgICAgbGlzdEh0bWwucHVzaCgnIGRpciA9IFwiYXV0b1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0SHRtbC5wdXNoKCc+Jyk7XG4gICAgICAgIGxpc3RIdG1sLnB1c2goZ2V0QmxvY2tJbm5lck1hcmt1cChibG9jaywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pKTtcbiAgICAgICAgbGlzdEh0bWwucHVzaCgnPC9saT5cXG4nKTtcbiAgICAgICAgcHJldmlvdXNCbG9jayA9IGJsb2NrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG5lc3RlZExpc3RCbG9jayAmJiBuZXN0ZWRMaXN0QmxvY2subGVuZ3RoID4gMCkge1xuICAgICAgbGlzdEh0bWwucHVzaChnZXRMaXN0TWFya3VwKG5lc3RlZExpc3RCbG9jaywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBkaXJlY3Rpb25hbCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSk7XG4gICAgfVxuXG4gICAgbGlzdEh0bWwucHVzaChcIjwvXCIuY29uY2F0KGdldEJsb2NrVGFnKHByZXZpb3VzQmxvY2sudHlwZSksIFwiPlxcblwiKSk7XG4gICAgcmV0dXJuIGxpc3RIdG1sLmpvaW4oJycpO1xuICB9XG5cbiAgLyoqXG4gICogVGhlIGZ1bmN0aW9uIHdpbGwgZ2VuZXJhdGUgaHRtbCBtYXJrdXAgZm9yIGdpdmVuIGRyYWZ0anMgZWRpdG9yQ29udGVudC5cbiAgKi9cblxuICBmdW5jdGlvbiBkcmFmdFRvSHRtbChlZGl0b3JDb250ZW50LCBoYXNodGFnQ29uZmlnLCBkaXJlY3Rpb25hbCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSB7XG4gICAgdmFyIGh0bWwgPSBbXTtcblxuICAgIGlmIChlZGl0b3JDb250ZW50KSB7XG4gICAgICB2YXIgYmxvY2tzID0gZWRpdG9yQ29udGVudC5ibG9ja3MsXG4gICAgICAgICAgZW50aXR5TWFwID0gZWRpdG9yQ29udGVudC5lbnRpdHlNYXA7XG5cbiAgICAgIGlmIChibG9ja3MgJiYgYmxvY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxpc3RCbG9ja3MgPSBbXTtcbiAgICAgICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgaWYgKGlzTGlzdChibG9jay50eXBlKSkge1xuICAgICAgICAgICAgbGlzdEJsb2Nrcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxpc3RCbG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgbGlzdEh0bWwgPSBnZXRMaXN0TWFya3VwKGxpc3RCbG9ja3MsIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgY3VzdG9tRW50aXR5VHJhbnNmb3JtKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG5cbiAgICAgICAgICAgICAgaHRtbC5wdXNoKGxpc3RIdG1sKTtcbiAgICAgICAgICAgICAgbGlzdEJsb2NrcyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYmxvY2tIdG1sID0gZ2V0QmxvY2tNYXJrdXAoYmxvY2ssIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgZGlyZWN0aW9uYWwsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSk7XG4gICAgICAgICAgICBodG1sLnB1c2goYmxvY2tIdG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChsaXN0QmxvY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGlzdEh0bWwgPSBnZXRMaXN0TWFya3VwKGxpc3RCbG9ja3MsIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgZGlyZWN0aW9uYWwsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuXG4gICAgICAgICAgaHRtbC5wdXNoKGxpc3RIdG1sKTtcbiAgICAgICAgICBsaXN0QmxvY2tzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbC5qb2luKCcnKTtcbiAgfVxuXG4gIHJldHVybiBkcmFmdFRvSHRtbDtcblxufSkpKTtcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsInNlbGYiLCJkcmFmdGpzVG9IdG1sIiwiZm9yRWFjaCIsIm9iaiIsImNhbGxiYWNrIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaXNFbXB0eVN0cmluZyIsInN0ciIsInVuZGVmaW5lZCIsImxlbmd0aCIsInRyaW0iLCJibG9ja1R5cGVzTWFwcGluZyIsInVuc3R5bGVkIiwiYmxvY2txdW90ZSIsImNvZGUiLCJnZXRCbG9ja1RhZyIsInR5cGUiLCJnZXRCbG9ja1N0eWxlIiwiZGF0YSIsInN0eWxlcyIsInZhbHVlIiwiY29uY2F0IiwiZ2V0SGFzaHRhZ1JhbmdlcyIsImJsb2NrVGV4dCIsImhhc2h0YWdDb25maWciLCJzZWN0aW9ucyIsImNvdW50ZXIiLCJzdGFydEluZGV4IiwidGV4dCIsInRyaWdnZXIiLCJzZXBhcmF0b3IiLCJzdWJzdHIiLCJpbmRleE9mIiwiZW5kSW5kZXgiLCJoYXNodGFnIiwicHVzaCIsIm9mZnNldCIsImdldFNlY3Rpb25zIiwiYmxvY2siLCJsYXN0T2Zmc2V0Iiwic2VjdGlvblJhbmdlcyIsImVudGl0eVJhbmdlcyIsIm1hcCIsInJhbmdlIiwic29ydCIsInMxIiwiczIiLCJyIiwic3RhcnQiLCJlbmQiLCJlbnRpdHlLZXkiLCJpc0F0b21pY0VudGl0eUJsb2NrIiwiZ2V0U3R5bGVBcnJheUZvckJsb2NrIiwiaW5saW5lU3R5bGVSYW5nZXMiLCJpbmxpbmVTdHlsZXMiLCJCT0xEIiwiQXJyYXkiLCJJVEFMSUMiLCJVTkRFUkxJTkUiLCJTVFJJS0VUSFJPVUdIIiwiQ09ERSIsIlNVUEVSU0NSSVBUIiwiU1VCU0NSSVBUIiwiQ09MT1IiLCJCR0NPTE9SIiwiRk9OVFNJWkUiLCJGT05URkFNSUxZIiwiaSIsInN0eWxlIiwic3Vic3RyaW5nIiwiZ2V0U3R5bGVzQXRPZmZzZXQiLCJzYW1lU3R5bGVBc1ByZXZpb3VzIiwiaW5kZXgiLCJzYW1lU3R5bGVkIiwiYWRkSW5saW5lU3R5bGVNYXJrdXAiLCJjb250ZW50IiwiZ2V0U2VjdGlvblRleHQiLCJjaGFycyIsImNoIiwiam9pbiIsImFkZFN0eWxlUHJvcGVydHlNYXJrdXAiLCJzdHlsZVN0cmluZyIsInRlc3QiLCJnZXRFbnRpdHlNYXJrdXAiLCJlbnRpdHlNYXAiLCJjdXN0b21FbnRpdHlUcmFuc2Zvcm0iLCJlbnRpdHkiLCJodG1sIiwidXJsIiwidGFyZ2V0T3B0aW9uIiwiYWxpZ25tZW50Iiwic3JjIiwiYWx0IiwiaGVpZ2h0Iiwid2lkdGgiLCJnZXRJbmxpbmVTdHlsZVNlY3Rpb25zIiwic3R5bGVTZWN0aW9ucyIsImZyb20iLCJzZWN0aW9uIiwidHJpbUxlYWRpbmdaZXJvcyIsInNlY3Rpb25UZXh0IiwicmVwbGFjZWRUZXh0IiwicmVwbGFjZSIsInRyaW1UcmFpbGluZ1plcm9zIiwiZ2V0U3R5bGVUYWdTZWN0aW9uTWFya3VwIiwic3R5bGVTZWN0aW9uIiwiZ2V0SW5saW5lU3R5bGVTZWN0aW9uTWFya3VwIiwic3R5bGVUYWdTZWN0aW9ucyIsInN0eWxlU2VjdGlvblRleHQiLCJzdHlsZVByb3BlcnR5U2VjdGlvbiIsImdldFNlY3Rpb25NYXJrdXAiLCJlbnRpdHlJbmxpbmVNYXJrdXAiLCJpbmxpbmVTdHlsZVNlY3Rpb25zIiwiZ2V0QmxvY2tJbm5lck1hcmt1cCIsImJsb2NrTWFya3VwIiwiZ2V0QmxvY2tNYXJrdXAiLCJkaXJlY3Rpb25hbCIsImJsb2NrSHRtbCIsImJsb2NrVGFnIiwiYmxvY2tTdHlsZSIsImlzTGlzdCIsImJsb2NrVHlwZSIsImdldExpc3RNYXJrdXAiLCJsaXN0QmxvY2tzIiwibGlzdEh0bWwiLCJuZXN0ZWRMaXN0QmxvY2siLCJwcmV2aW91c0Jsb2NrIiwibmVzdGVkQmxvY2siLCJkZXB0aCIsImRyYWZ0VG9IdG1sIiwiZWRpdG9yQ29udGVudCIsImJsb2NrcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/draftjs-to-html/lib/draftjs-to-html.js\n");

/***/ })

};
;